<?php

/**
 * Base class that represents a row from the 'piwam_membre' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.3.0-dev on:
 *
 * Mon Nov  9 18:14:02 2009
 *
 * @package    lib.model.om
 */
abstract class BaseMembre extends BaseObject  implements Persistent {


  const PEER = 'MembrePeer';

	/**
	 * The Peer class.
	 * Instance provides a convenient way of calling static methods on a class
	 * that calling code may not be able to identify.
	 * @var        MembrePeer
	 */
	protected static $peer;

	/**
	 * The value for the id field.
	 * @var        int
	 */
	protected $id;

	/**
	 * The value for the nom field.
	 * @var        string
	 */
	protected $nom;

	/**
	 * The value for the prenom field.
	 * @var        string
	 */
	protected $prenom;

	/**
	 * The value for the pseudo field.
	 * @var        string
	 */
	protected $pseudo;

	/**
	 * The value for the password field.
	 * @var        string
	 */
	protected $password;

	/**
	 * The value for the statut_id field.
	 * @var        int
	 */
	protected $statut_id;

	/**
	 * The value for the date_inscription field.
	 * @var        string
	 */
	protected $date_inscription;

	/**
	 * The value for the exempte_cotisation field.
	 * @var        boolean
	 */
	protected $exempte_cotisation;

	/**
	 * The value for the rue field.
	 * @var        string
	 */
	protected $rue;

	/**
	 * The value for the cp field.
	 * @var        string
	 */
	protected $cp;

	/**
	 * The value for the ville field.
	 * @var        string
	 */
	protected $ville;

	/**
	 * The value for the pays field.
	 * @var        string
	 */
	protected $pays;

	/**
	 * The value for the picture field.
	 * @var        string
	 */
	protected $picture;

	/**
	 * The value for the email field.
	 * @var        string
	 */
	protected $email;

	/**
	 * The value for the website field.
	 * @var        string
	 */
	protected $website;

	/**
	 * The value for the tel_fixe field.
	 * @var        string
	 */
	protected $tel_fixe;

	/**
	 * The value for the tel_portable field.
	 * @var        string
	 */
	protected $tel_portable;

	/**
	 * The value for the actif field.
	 * Note: this column has a database default value of: 1
	 * @var        int
	 */
	protected $actif;

	/**
	 * The value for the association_id field.
	 * @var        int
	 */
	protected $association_id;

	/**
	 * The value for the enregistre_par field.
	 * @var        int
	 */
	protected $enregistre_par;

	/**
	 * The value for the mis_a_jour_par field.
	 * @var        int
	 */
	protected $mis_a_jour_par;

	/**
	 * The value for the created_at field.
	 * @var        string
	 */
	protected $created_at;

	/**
	 * The value for the updated_at field.
	 * @var        string
	 */
	protected $updated_at;

	/**
	 * @var        Statut
	 */
	protected $aStatut;

	/**
	 * @var        Association
	 */
	protected $aAssociation;

	/**
	 * @var        Membre
	 */
	protected $aMembreRelatedByEnregistrePar;

	/**
	 * @var        Membre
	 */
	protected $aMembreRelatedByMisAJourPar;

	/**
	 * @var        array AclCredential[] Collection to store aggregation of AclCredential objects.
	 */
	protected $collAclCredentials;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAclCredentials.
	 */
	private $lastAclCredentialCriteria = null;

	/**
	 * @var        array Activite[] Collection to store aggregation of Activite objects.
	 */
	protected $collActivitesRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collActivitesRelatedByEnregistrePar.
	 */
	private $lastActiviteRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Activite[] Collection to store aggregation of Activite objects.
	 */
	protected $collActivitesRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collActivitesRelatedByMisAJourPar.
	 */
	private $lastActiviteRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Association[] Collection to store aggregation of Association objects.
	 */
	protected $collAssociationsRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAssociationsRelatedByEnregistrePar.
	 */
	private $lastAssociationRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Association[] Collection to store aggregation of Association objects.
	 */
	protected $collAssociationsRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collAssociationsRelatedByMisAJourPar.
	 */
	private $lastAssociationRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Compte[] Collection to store aggregation of Compte objects.
	 */
	protected $collComptesRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collComptesRelatedByEnregistrePar.
	 */
	private $lastCompteRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Compte[] Collection to store aggregation of Compte objects.
	 */
	protected $collComptesRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collComptesRelatedByMisAJourPar.
	 */
	private $lastCompteRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Cotisation[] Collection to store aggregation of Cotisation objects.
	 */
	protected $collCotisationsRelatedByMembreId;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCotisationsRelatedByMembreId.
	 */
	private $lastCotisationRelatedByMembreIdCriteria = null;

	/**
	 * @var        array Cotisation[] Collection to store aggregation of Cotisation objects.
	 */
	protected $collCotisationsRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCotisationsRelatedByEnregistrePar.
	 */
	private $lastCotisationRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Cotisation[] Collection to store aggregation of Cotisation objects.
	 */
	protected $collCotisationsRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCotisationsRelatedByMisAJourPar.
	 */
	private $lastCotisationRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array CotisationType[] Collection to store aggregation of CotisationType objects.
	 */
	protected $collCotisationTypesRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCotisationTypesRelatedByEnregistrePar.
	 */
	private $lastCotisationTypeRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array CotisationType[] Collection to store aggregation of CotisationType objects.
	 */
	protected $collCotisationTypesRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collCotisationTypesRelatedByMisAJourPar.
	 */
	private $lastCotisationTypeRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Depense[] Collection to store aggregation of Depense objects.
	 */
	protected $collDepensesRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDepensesRelatedByEnregistrePar.
	 */
	private $lastDepenseRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Depense[] Collection to store aggregation of Depense objects.
	 */
	protected $collDepensesRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collDepensesRelatedByMisAJourPar.
	 */
	private $lastDepenseRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Membre[] Collection to store aggregation of Membre objects.
	 */
	protected $collMembresRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collMembresRelatedByEnregistrePar.
	 */
	private $lastMembreRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Membre[] Collection to store aggregation of Membre objects.
	 */
	protected $collMembresRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collMembresRelatedByMisAJourPar.
	 */
	private $lastMembreRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Recette[] Collection to store aggregation of Recette objects.
	 */
	protected $collRecettesRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collRecettesRelatedByEnregistrePar.
	 */
	private $lastRecetteRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Recette[] Collection to store aggregation of Recette objects.
	 */
	protected $collRecettesRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collRecettesRelatedByMisAJourPar.
	 */
	private $lastRecetteRelatedByMisAJourParCriteria = null;

	/**
	 * @var        array Statut[] Collection to store aggregation of Statut objects.
	 */
	protected $collStatutsRelatedByEnregistrePar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStatutsRelatedByEnregistrePar.
	 */
	private $lastStatutRelatedByEnregistreParCriteria = null;

	/**
	 * @var        array Statut[] Collection to store aggregation of Statut objects.
	 */
	protected $collStatutsRelatedByMisAJourPar;

	/**
	 * @var        Criteria The criteria used to select the current contents of collStatutsRelatedByMisAJourPar.
	 */
	private $lastStatutRelatedByMisAJourParCriteria = null;

	/**
	 * Flag to prevent endless save loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInSave = false;

	/**
	 * Flag to prevent endless validation loop, if this object is referenced
	 * by another object which falls in this transaction.
	 * @var        boolean
	 */
	protected $alreadyInValidation = false;

	/**
	 * Initializes internal state of BaseMembre object.
	 * @see        applyDefaults()
	 */
	public function __construct()
	{
		parent::__construct();
		$this->applyDefaultValues();
	}

	/**
	 * Applies default values to this object.
	 * This method should be called from the object's constructor (or
	 * equivalent initialization method).
	 * @see        __construct()
	 */
	public function applyDefaultValues()
	{
		$this->actif = 1;
	}

	/**
	 * Get the [id] column value.
	 * 
	 * @return     int
	 */
	public function getId()
	{
		return $this->id;
	}

	/**
	 * Get the [nom] column value.
	 * 
	 * @return     string
	 */
	public function getNom()
	{
		return $this->nom;
	}

	/**
	 * Get the [prenom] column value.
	 * 
	 * @return     string
	 */
	public function getPrenom()
	{
		return $this->prenom;
	}

	/**
	 * Get the [pseudo] column value.
	 * 
	 * @return     string
	 */
	public function getPseudo()
	{
		return $this->pseudo;
	}

	/**
	 * Get the [password] column value.
	 * 
	 * @return     string
	 */
	public function getPassword()
	{
		return $this->password;
	}

	/**
	 * Get the [statut_id] column value.
	 * 
	 * @return     int
	 */
	public function getStatutId()
	{
		return $this->statut_id;
	}

	/**
	 * Get the [optionally formatted] temporal [date_inscription] column value.
	 * 
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL, and 0 if column value is 0000-00-00
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getDateInscription($format = 'Y-m-d')
	{
		if ($this->date_inscription === null) {
			return null;
		}


		if ($this->date_inscription === '0000-00-00') {
			// while technically this is not a default value of NULL,
			// this seems to be closest in meaning.
			return null;
		} else {
			try {
				$dt = new DateTime($this->date_inscription);
			} catch (Exception $x) {
				throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->date_inscription, true), $x);
			}
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Get the [exempte_cotisation] column value.
	 * 
	 * @return     boolean
	 */
	public function getExempteCotisation()
	{
		return $this->exempte_cotisation;
	}

	/**
	 * Get the [rue] column value.
	 * 
	 * @return     string
	 */
	public function getRue()
	{
		return $this->rue;
	}

	/**
	 * Get the [cp] column value.
	 * 
	 * @return     string
	 */
	public function getCp()
	{
		return $this->cp;
	}

	/**
	 * Get the [ville] column value.
	 * 
	 * @return     string
	 */
	public function getVille()
	{
		return $this->ville;
	}

	/**
	 * Get the [pays] column value.
	 * 
	 * @return     string
	 */
	public function getPays()
	{
		return $this->pays;
	}

	/**
	 * Get the [picture] column value.
	 * 
	 * @return     string
	 */
	public function getPicture()
	{
		return $this->picture;
	}

	/**
	 * Get the [email] column value.
	 * 
	 * @return     string
	 */
	public function getEmail()
	{
		return $this->email;
	}

	/**
	 * Get the [website] column value.
	 * 
	 * @return     string
	 */
	public function getWebsite()
	{
		return $this->website;
	}

	/**
	 * Get the [tel_fixe] column value.
	 * 
	 * @return     string
	 */
	public function getTelFixe()
	{
		return $this->tel_fixe;
	}

	/**
	 * Get the [tel_portable] column value.
	 * 
	 * @return     string
	 */
	public function getTelPortable()
	{
		return $this->tel_portable;
	}

	/**
	 * Get the [actif] column value.
	 * 
	 * @return     int
	 */
	public function getActif()
	{
		return $this->actif;
	}

	/**
	 * Get the [association_id] column value.
	 * 
	 * @return     int
	 */
	public function getAssociationId()
	{
		return $this->association_id;
	}

	/**
	 * Get the [enregistre_par] column value.
	 * 
	 * @return     int
	 */
	public function getEnregistrePar()
	{
		return $this->enregistre_par;
	}

	/**
	 * Get the [mis_a_jour_par] column value.
	 * 
	 * @return     int
	 */
	public function getMisAJourPar()
	{
		return $this->mis_a_jour_par;
	}

	/**
	 * Get the [optionally formatted] temporal [created_at] column value.
	 * 
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL, and 0 if column value is 0000-00-00 00:00:00
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getCreatedAt($format = 'Y-m-d H:i:s')
	{
		if ($this->created_at === null) {
			return null;
		}


		if ($this->created_at === '0000-00-00 00:00:00') {
			// while technically this is not a default value of NULL,
			// this seems to be closest in meaning.
			return null;
		} else {
			try {
				$dt = new DateTime($this->created_at);
			} catch (Exception $x) {
				throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->created_at, true), $x);
			}
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Get the [optionally formatted] temporal [updated_at] column value.
	 * 
	 *
	 * @param      string $format The date/time format string (either date()-style or strftime()-style).
	 *							If format is NULL, then the raw DateTime object will be returned.
	 * @return     mixed Formatted date/time value as string or DateTime object (if format is NULL), NULL if column is NULL, and 0 if column value is 0000-00-00 00:00:00
	 * @throws     PropelException - if unable to parse/validate the date/time value.
	 */
	public function getUpdatedAt($format = 'Y-m-d H:i:s')
	{
		if ($this->updated_at === null) {
			return null;
		}


		if ($this->updated_at === '0000-00-00 00:00:00') {
			// while technically this is not a default value of NULL,
			// this seems to be closest in meaning.
			return null;
		} else {
			try {
				$dt = new DateTime($this->updated_at);
			} catch (Exception $x) {
				throw new PropelException("Internally stored date/time/timestamp value could not be converted to DateTime: " . var_export($this->updated_at, true), $x);
			}
		}

		if ($format === null) {
			// Because propel.useDateTimeClass is TRUE, we return a DateTime object.
			return $dt;
		} elseif (strpos($format, '%') !== false) {
			return strftime($format, $dt->format('U'));
		} else {
			return $dt->format($format);
		}
	}

	/**
	 * Set the value of [id] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->id !== $v) {
			$this->id = $v;
			$this->modifiedColumns[] = MembrePeer::ID;
		}

		return $this;
	} // setId()

	/**
	 * Set the value of [nom] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setNom($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->nom !== $v) {
			$this->nom = $v;
			$this->modifiedColumns[] = MembrePeer::NOM;
		}

		return $this;
	} // setNom()

	/**
	 * Set the value of [prenom] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setPrenom($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->prenom !== $v) {
			$this->prenom = $v;
			$this->modifiedColumns[] = MembrePeer::PRENOM;
		}

		return $this;
	} // setPrenom()

	/**
	 * Set the value of [pseudo] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setPseudo($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->pseudo !== $v) {
			$this->pseudo = $v;
			$this->modifiedColumns[] = MembrePeer::PSEUDO;
		}

		return $this;
	} // setPseudo()

	/**
	 * Set the value of [password] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setPassword($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->password !== $v) {
			$this->password = $v;
			$this->modifiedColumns[] = MembrePeer::PASSWORD;
		}

		return $this;
	} // setPassword()

	/**
	 * Set the value of [statut_id] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setStatutId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->statut_id !== $v) {
			$this->statut_id = $v;
			$this->modifiedColumns[] = MembrePeer::STATUT_ID;
		}

		if ($this->aStatut !== null && $this->aStatut->getId() !== $v) {
			$this->aStatut = null;
		}

		return $this;
	} // setStatutId()

	/**
	 * Sets the value of [date_inscription] column to a normalized version of the date/time value specified.
	 * 
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setDateInscription($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->date_inscription !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->date_inscription !== null && $tmpDt = new DateTime($this->date_inscription)) ? $tmpDt->format('Y-m-d') : null;
			$newNorm = ($dt !== null) ? $dt->format('Y-m-d') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->date_inscription = ($dt ? $dt->format('Y-m-d') : null);
				$this->modifiedColumns[] = MembrePeer::DATE_INSCRIPTION;
			}
		} // if either are not null

		return $this;
	} // setDateInscription()

	/**
	 * Set the value of [exempte_cotisation] column.
	 * 
	 * @param      boolean $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setExempteCotisation($v)
	{
		if ($v !== null) {
			$v = (boolean) $v;
		}

		if ($this->exempte_cotisation !== $v) {
			$this->exempte_cotisation = $v;
			$this->modifiedColumns[] = MembrePeer::EXEMPTE_COTISATION;
		}

		return $this;
	} // setExempteCotisation()

	/**
	 * Set the value of [rue] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setRue($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->rue !== $v) {
			$this->rue = $v;
			$this->modifiedColumns[] = MembrePeer::RUE;
		}

		return $this;
	} // setRue()

	/**
	 * Set the value of [cp] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setCp($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->cp !== $v) {
			$this->cp = $v;
			$this->modifiedColumns[] = MembrePeer::CP;
		}

		return $this;
	} // setCp()

	/**
	 * Set the value of [ville] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setVille($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->ville !== $v) {
			$this->ville = $v;
			$this->modifiedColumns[] = MembrePeer::VILLE;
		}

		return $this;
	} // setVille()

	/**
	 * Set the value of [pays] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setPays($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->pays !== $v) {
			$this->pays = $v;
			$this->modifiedColumns[] = MembrePeer::PAYS;
		}

		return $this;
	} // setPays()

	/**
	 * Set the value of [picture] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setPicture($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->picture !== $v) {
			$this->picture = $v;
			$this->modifiedColumns[] = MembrePeer::PICTURE;
		}

		return $this;
	} // setPicture()

	/**
	 * Set the value of [email] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setEmail($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->email !== $v) {
			$this->email = $v;
			$this->modifiedColumns[] = MembrePeer::EMAIL;
		}

		return $this;
	} // setEmail()

	/**
	 * Set the value of [website] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setWebsite($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->website !== $v) {
			$this->website = $v;
			$this->modifiedColumns[] = MembrePeer::WEBSITE;
		}

		return $this;
	} // setWebsite()

	/**
	 * Set the value of [tel_fixe] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setTelFixe($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->tel_fixe !== $v) {
			$this->tel_fixe = $v;
			$this->modifiedColumns[] = MembrePeer::TEL_FIXE;
		}

		return $this;
	} // setTelFixe()

	/**
	 * Set the value of [tel_portable] column.
	 * 
	 * @param      string $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setTelPortable($v)
	{
		if ($v !== null) {
			$v = (string) $v;
		}

		if ($this->tel_portable !== $v) {
			$this->tel_portable = $v;
			$this->modifiedColumns[] = MembrePeer::TEL_PORTABLE;
		}

		return $this;
	} // setTelPortable()

	/**
	 * Set the value of [actif] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setActif($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->actif !== $v || $v === 1) {
			$this->actif = $v;
			$this->modifiedColumns[] = MembrePeer::ACTIF;
		}

		return $this;
	} // setActif()

	/**
	 * Set the value of [association_id] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setAssociationId($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->association_id !== $v) {
			$this->association_id = $v;
			$this->modifiedColumns[] = MembrePeer::ASSOCIATION_ID;
		}

		if ($this->aAssociation !== null && $this->aAssociation->getId() !== $v) {
			$this->aAssociation = null;
		}

		return $this;
	} // setAssociationId()

	/**
	 * Set the value of [enregistre_par] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setEnregistrePar($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->enregistre_par !== $v) {
			$this->enregistre_par = $v;
			$this->modifiedColumns[] = MembrePeer::ENREGISTRE_PAR;
		}

		if ($this->aMembreRelatedByEnregistrePar !== null && $this->aMembreRelatedByEnregistrePar->getId() !== $v) {
			$this->aMembreRelatedByEnregistrePar = null;
		}

		return $this;
	} // setEnregistrePar()

	/**
	 * Set the value of [mis_a_jour_par] column.
	 * 
	 * @param      int $v new value
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setMisAJourPar($v)
	{
		if ($v !== null) {
			$v = (int) $v;
		}

		if ($this->mis_a_jour_par !== $v) {
			$this->mis_a_jour_par = $v;
			$this->modifiedColumns[] = MembrePeer::MIS_A_JOUR_PAR;
		}

		if ($this->aMembreRelatedByMisAJourPar !== null && $this->aMembreRelatedByMisAJourPar->getId() !== $v) {
			$this->aMembreRelatedByMisAJourPar = null;
		}

		return $this;
	} // setMisAJourPar()

	/**
	 * Sets the value of [created_at] column to a normalized version of the date/time value specified.
	 * 
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setCreatedAt($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->created_at !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->created_at !== null && $tmpDt = new DateTime($this->created_at)) ? $tmpDt->format('Y-m-d H:i:s') : null;
			$newNorm = ($dt !== null) ? $dt->format('Y-m-d H:i:s') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->created_at = ($dt ? $dt->format('Y-m-d H:i:s') : null);
				$this->modifiedColumns[] = MembrePeer::CREATED_AT;
			}
		} // if either are not null

		return $this;
	} // setCreatedAt()

	/**
	 * Sets the value of [updated_at] column to a normalized version of the date/time value specified.
	 * 
	 * @param      mixed $v string, integer (timestamp), or DateTime value.  Empty string will
	 *						be treated as NULL for temporal objects.
	 * @return     Membre The current object (for fluent API support)
	 */
	public function setUpdatedAt($v)
	{
		// we treat '' as NULL for temporal objects because DateTime('') == DateTime('now')
		// -- which is unexpected, to say the least.
		if ($v === null || $v === '') {
			$dt = null;
		} elseif ($v instanceof DateTime) {
			$dt = $v;
		} else {
			// some string/numeric value passed; we normalize that so that we can
			// validate it.
			try {
				if (is_numeric($v)) { // if it's a unix timestamp
					$dt = new DateTime('@'.$v, new DateTimeZone('UTC'));
					// We have to explicitly specify and then change the time zone because of a
					// DateTime bug: http://bugs.php.net/bug.php?id=43003
					$dt->setTimeZone(new DateTimeZone(date_default_timezone_get()));
				} else {
					$dt = new DateTime($v);
				}
			} catch (Exception $x) {
				throw new PropelException('Error parsing date/time value: ' . var_export($v, true), $x);
			}
		}

		if ( $this->updated_at !== null || $dt !== null ) {
			// (nested ifs are a little easier to read in this case)

			$currNorm = ($this->updated_at !== null && $tmpDt = new DateTime($this->updated_at)) ? $tmpDt->format('Y-m-d H:i:s') : null;
			$newNorm = ($dt !== null) ? $dt->format('Y-m-d H:i:s') : null;

			if ( ($currNorm !== $newNorm) // normalized values don't match 
					)
			{
				$this->updated_at = ($dt ? $dt->format('Y-m-d H:i:s') : null);
				$this->modifiedColumns[] = MembrePeer::UPDATED_AT;
			}
		} // if either are not null

		return $this;
	} // setUpdatedAt()

	/**
	 * Indicates whether the columns in this object are only set to default values.
	 *
	 * This method can be used in conjunction with isModified() to indicate whether an object is both
	 * modified _and_ has some values set which are non-default.
	 *
	 * @return     boolean Whether the columns in this object are only been set with default values.
	 */
	public function hasOnlyDefaultValues()
	{
			// First, ensure that we don't have any columns that have been modified which aren't default columns.
			if (array_diff($this->modifiedColumns, array(MembrePeer::ACTIF))) {
				return false;
			}

			if ($this->actif !== 1) {
				return false;
			}

		// otherwise, everything was equal, so return TRUE
		return true;
	} // hasOnlyDefaultValues()

	/**
	 * Hydrates (populates) the object variables with values from the database resultset.
	 *
	 * An offset (0-based "start column") is specified so that objects can be hydrated
	 * with a subset of the columns in the resultset rows.  This is needed, for example,
	 * for results of JOIN queries where the resultset row includes columns from two or
	 * more tables.
	 *
	 * @param      array $row The row returned by PDOStatement->fetch(PDO::FETCH_NUM)
	 * @param      int $startcol 0-based offset column which indicates which restultset column to start with.
	 * @param      boolean $rehydrate Whether this object is being re-hydrated from the database.
	 * @return     int next starting column
	 * @throws     PropelException  - Any caught Exception will be rewrapped as a PropelException.
	 */
	public function hydrate($row, $startcol = 0, $rehydrate = false)
	{
		try {

			$this->id = ($row[$startcol + 0] !== null) ? (int) $row[$startcol + 0] : null;
			$this->nom = ($row[$startcol + 1] !== null) ? (string) $row[$startcol + 1] : null;
			$this->prenom = ($row[$startcol + 2] !== null) ? (string) $row[$startcol + 2] : null;
			$this->pseudo = ($row[$startcol + 3] !== null) ? (string) $row[$startcol + 3] : null;
			$this->password = ($row[$startcol + 4] !== null) ? (string) $row[$startcol + 4] : null;
			$this->statut_id = ($row[$startcol + 5] !== null) ? (int) $row[$startcol + 5] : null;
			$this->date_inscription = ($row[$startcol + 6] !== null) ? (string) $row[$startcol + 6] : null;
			$this->exempte_cotisation = ($row[$startcol + 7] !== null) ? (boolean) $row[$startcol + 7] : null;
			$this->rue = ($row[$startcol + 8] !== null) ? (string) $row[$startcol + 8] : null;
			$this->cp = ($row[$startcol + 9] !== null) ? (string) $row[$startcol + 9] : null;
			$this->ville = ($row[$startcol + 10] !== null) ? (string) $row[$startcol + 10] : null;
			$this->pays = ($row[$startcol + 11] !== null) ? (string) $row[$startcol + 11] : null;
			$this->picture = ($row[$startcol + 12] !== null) ? (string) $row[$startcol + 12] : null;
			$this->email = ($row[$startcol + 13] !== null) ? (string) $row[$startcol + 13] : null;
			$this->website = ($row[$startcol + 14] !== null) ? (string) $row[$startcol + 14] : null;
			$this->tel_fixe = ($row[$startcol + 15] !== null) ? (string) $row[$startcol + 15] : null;
			$this->tel_portable = ($row[$startcol + 16] !== null) ? (string) $row[$startcol + 16] : null;
			$this->actif = ($row[$startcol + 17] !== null) ? (int) $row[$startcol + 17] : null;
			$this->association_id = ($row[$startcol + 18] !== null) ? (int) $row[$startcol + 18] : null;
			$this->enregistre_par = ($row[$startcol + 19] !== null) ? (int) $row[$startcol + 19] : null;
			$this->mis_a_jour_par = ($row[$startcol + 20] !== null) ? (int) $row[$startcol + 20] : null;
			$this->created_at = ($row[$startcol + 21] !== null) ? (string) $row[$startcol + 21] : null;
			$this->updated_at = ($row[$startcol + 22] !== null) ? (string) $row[$startcol + 22] : null;
			$this->resetModified();

			$this->setNew(false);

			if ($rehydrate) {
				$this->ensureConsistency();
			}

			// FIXME - using NUM_COLUMNS may be clearer.
			return $startcol + 23; // 23 = MembrePeer::NUM_COLUMNS - MembrePeer::NUM_LAZY_LOAD_COLUMNS).

		} catch (Exception $e) {
			throw new PropelException("Error populating Membre object", $e);
		}
	}

	/**
	 * Checks and repairs the internal consistency of the object.
	 *
	 * This method is executed after an already-instantiated object is re-hydrated
	 * from the database.  It exists to check any foreign keys to make sure that
	 * the objects related to the current object are correct based on foreign key.
	 *
	 * You can override this method in the stub class, but you should always invoke
	 * the base method from the overridden method (i.e. parent::ensureConsistency()),
	 * in case your model changes.
	 *
	 * @throws     PropelException
	 */
	public function ensureConsistency()
	{

		if ($this->aStatut !== null && $this->statut_id !== $this->aStatut->getId()) {
			$this->aStatut = null;
		}
		if ($this->aAssociation !== null && $this->association_id !== $this->aAssociation->getId()) {
			$this->aAssociation = null;
		}
		if ($this->aMembreRelatedByEnregistrePar !== null && $this->enregistre_par !== $this->aMembreRelatedByEnregistrePar->getId()) {
			$this->aMembreRelatedByEnregistrePar = null;
		}
		if ($this->aMembreRelatedByMisAJourPar !== null && $this->mis_a_jour_par !== $this->aMembreRelatedByMisAJourPar->getId()) {
			$this->aMembreRelatedByMisAJourPar = null;
		}
	} // ensureConsistency

	/**
	 * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
	 *
	 * This will only work if the object has been saved and has a valid primary key set.
	 *
	 * @param      boolean $deep (optional) Whether to also de-associated any related objects.
	 * @param      PropelPDO $con (optional) The PropelPDO connection to use.
	 * @return     void
	 * @throws     PropelException - if this object is deleted, unsaved or doesn't have pk match in db
	 */
	public function reload($deep = false, PropelPDO $con = null)
	{
		if ($this->isDeleted()) {
			throw new PropelException("Cannot reload a deleted object.");
		}

		if ($this->isNew()) {
			throw new PropelException("Cannot reload an unsaved object.");
		}

		if ($con === null) {
			$con = Propel::getConnection(MembrePeer::DATABASE_NAME, Propel::CONNECTION_READ);
		}

		// We don't need to alter the object instance pool; we're just modifying this instance
		// already in the pool.

		$stmt = MembrePeer::doSelectStmt($this->buildPkeyCriteria(), $con);
		$row = $stmt->fetch(PDO::FETCH_NUM);
		$stmt->closeCursor();
		if (!$row) {
			throw new PropelException('Cannot find matching row in the database to reload object values.');
		}
		$this->hydrate($row, 0, true); // rehydrate

		if ($deep) {  // also de-associate any related objects?

			$this->aStatut = null;
			$this->aAssociation = null;
			$this->aMembreRelatedByEnregistrePar = null;
			$this->aMembreRelatedByMisAJourPar = null;
			$this->collAclCredentials = null;
			$this->lastAclCredentialCriteria = null;

			$this->collActivitesRelatedByEnregistrePar = null;
			$this->lastActiviteRelatedByEnregistreParCriteria = null;

			$this->collActivitesRelatedByMisAJourPar = null;
			$this->lastActiviteRelatedByMisAJourParCriteria = null;

			$this->collAssociationsRelatedByEnregistrePar = null;
			$this->lastAssociationRelatedByEnregistreParCriteria = null;

			$this->collAssociationsRelatedByMisAJourPar = null;
			$this->lastAssociationRelatedByMisAJourParCriteria = null;

			$this->collComptesRelatedByEnregistrePar = null;
			$this->lastCompteRelatedByEnregistreParCriteria = null;

			$this->collComptesRelatedByMisAJourPar = null;
			$this->lastCompteRelatedByMisAJourParCriteria = null;

			$this->collCotisationsRelatedByMembreId = null;
			$this->lastCotisationRelatedByMembreIdCriteria = null;

			$this->collCotisationsRelatedByEnregistrePar = null;
			$this->lastCotisationRelatedByEnregistreParCriteria = null;

			$this->collCotisationsRelatedByMisAJourPar = null;
			$this->lastCotisationRelatedByMisAJourParCriteria = null;

			$this->collCotisationTypesRelatedByEnregistrePar = null;
			$this->lastCotisationTypeRelatedByEnregistreParCriteria = null;

			$this->collCotisationTypesRelatedByMisAJourPar = null;
			$this->lastCotisationTypeRelatedByMisAJourParCriteria = null;

			$this->collDepensesRelatedByEnregistrePar = null;
			$this->lastDepenseRelatedByEnregistreParCriteria = null;

			$this->collDepensesRelatedByMisAJourPar = null;
			$this->lastDepenseRelatedByMisAJourParCriteria = null;

			$this->collMembresRelatedByEnregistrePar = null;
			$this->lastMembreRelatedByEnregistreParCriteria = null;

			$this->collMembresRelatedByMisAJourPar = null;
			$this->lastMembreRelatedByMisAJourParCriteria = null;

			$this->collRecettesRelatedByEnregistrePar = null;
			$this->lastRecetteRelatedByEnregistreParCriteria = null;

			$this->collRecettesRelatedByMisAJourPar = null;
			$this->lastRecetteRelatedByMisAJourParCriteria = null;

			$this->collStatutsRelatedByEnregistrePar = null;
			$this->lastStatutRelatedByEnregistreParCriteria = null;

			$this->collStatutsRelatedByMisAJourPar = null;
			$this->lastStatutRelatedByMisAJourParCriteria = null;

		} // if (deep)
	}

	/**
	 * Removes this object from datastore and sets delete attribute.
	 *
	 * @param      PropelPDO $con
	 * @return     void
	 * @throws     PropelException
	 * @see        BaseObject::setDeleted()
	 * @see        BaseObject::isDeleted()
	 */
	public function delete(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseMembre:delete:pre') as $callable)
    {
      $ret = call_user_func($callable, $this, $con);
      if ($ret)
      {
        return;
      }
    }


		if ($this->isDeleted()) {
			throw new PropelException("This object has already been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(MembrePeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			MembrePeer::doDelete($this, $con);
			$this->setDeleted(true);
			$con->commit();
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	

    foreach (sfMixer::getCallables('BaseMembre:delete:post') as $callable)
    {
      call_user_func($callable, $this, $con);
    }

  }
	/**
	 * Persists this object to the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All modified related objects will also be persisted in the doSave()
	 * method.  This method wraps all precipitate database operations in a
	 * single transaction.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        doSave()
	 */
	public function save(PropelPDO $con = null)
	{

    foreach (sfMixer::getCallables('BaseMembre:save:pre') as $callable)
    {
      $affectedRows = call_user_func($callable, $this, $con);
      if (is_int($affectedRows))
      {
        return $affectedRows;
      }
    }


    if ($this->isNew() && !$this->isColumnModified(MembrePeer::CREATED_AT))
    {
      $this->setCreatedAt(time());
    }

    if ($this->isModified() && !$this->isColumnModified(MembrePeer::UPDATED_AT))
    {
      $this->setUpdatedAt(time());
    }

		if ($this->isDeleted()) {
			throw new PropelException("You cannot save an object that has been deleted.");
		}

		if ($con === null) {
			$con = Propel::getConnection(MembrePeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		
		$con->beginTransaction();
		try {
			$affectedRows = $this->doSave($con);
			$con->commit();
    foreach (sfMixer::getCallables('BaseMembre:save:post') as $callable)
    {
      call_user_func($callable, $this, $con, $affectedRows);
    }

			MembrePeer::addInstanceToPool($this);
			return $affectedRows;
		} catch (PropelException $e) {
			$con->rollBack();
			throw $e;
		}
	}

	/**
	 * Performs the work of inserting or updating the row in the database.
	 *
	 * If the object is new, it inserts it; otherwise an update is performed.
	 * All related objects are also updated in this method.
	 *
	 * @param      PropelPDO $con
	 * @return     int The number of rows affected by this insert/update and any referring fk objects' save() operations.
	 * @throws     PropelException
	 * @see        save()
	 */
	protected function doSave(PropelPDO $con)
	{
		$affectedRows = 0; // initialize var to track total num of affected rows
		if (!$this->alreadyInSave) {
			$this->alreadyInSave = true;

			// We call the save method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aStatut !== null) {
				if ($this->aStatut->isModified() || $this->aStatut->isNew()) {
					$affectedRows += $this->aStatut->save($con);
				}
				$this->setStatut($this->aStatut);
			}

			if ($this->aAssociation !== null) {
				if ($this->aAssociation->isModified() || $this->aAssociation->isNew()) {
					$affectedRows += $this->aAssociation->save($con);
				}
				$this->setAssociation($this->aAssociation);
			}

			if ($this->aMembreRelatedByEnregistrePar !== null) {
				if ($this->aMembreRelatedByEnregistrePar->isModified() || $this->aMembreRelatedByEnregistrePar->isNew()) {
					$affectedRows += $this->aMembreRelatedByEnregistrePar->save($con);
				}
				$this->setMembreRelatedByEnregistrePar($this->aMembreRelatedByEnregistrePar);
			}

			if ($this->aMembreRelatedByMisAJourPar !== null) {
				if ($this->aMembreRelatedByMisAJourPar->isModified() || $this->aMembreRelatedByMisAJourPar->isNew()) {
					$affectedRows += $this->aMembreRelatedByMisAJourPar->save($con);
				}
				$this->setMembreRelatedByMisAJourPar($this->aMembreRelatedByMisAJourPar);
			}

			if ($this->isNew() ) {
				$this->modifiedColumns[] = MembrePeer::ID;
			}

			// If this object has been modified, then save it to the database.
			if ($this->isModified()) {
				if ($this->isNew()) {
					$pk = MembrePeer::doInsert($this, $con);
					$affectedRows += 1; // we are assuming that there is only 1 row per doInsert() which
										 // should always be true here (even though technically
										 // BasePeer::doInsert() can insert multiple rows).

					$this->setId($pk);  //[IMV] update autoincrement primary key

					$this->setNew(false);
				} else {
					$affectedRows += MembrePeer::doUpdate($this, $con);
				}

				$this->resetModified(); // [HL] After being saved an object is no longer 'modified'
			}

			if ($this->collAclCredentials !== null) {
				foreach ($this->collAclCredentials as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collActivitesRelatedByEnregistrePar !== null) {
				foreach ($this->collActivitesRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collActivitesRelatedByMisAJourPar !== null) {
				foreach ($this->collActivitesRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collAssociationsRelatedByEnregistrePar !== null) {
				foreach ($this->collAssociationsRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collAssociationsRelatedByMisAJourPar !== null) {
				foreach ($this->collAssociationsRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collComptesRelatedByEnregistrePar !== null) {
				foreach ($this->collComptesRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collComptesRelatedByMisAJourPar !== null) {
				foreach ($this->collComptesRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCotisationsRelatedByMembreId !== null) {
				foreach ($this->collCotisationsRelatedByMembreId as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCotisationsRelatedByEnregistrePar !== null) {
				foreach ($this->collCotisationsRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCotisationsRelatedByMisAJourPar !== null) {
				foreach ($this->collCotisationsRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCotisationTypesRelatedByEnregistrePar !== null) {
				foreach ($this->collCotisationTypesRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collCotisationTypesRelatedByMisAJourPar !== null) {
				foreach ($this->collCotisationTypesRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDepensesRelatedByEnregistrePar !== null) {
				foreach ($this->collDepensesRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collDepensesRelatedByMisAJourPar !== null) {
				foreach ($this->collDepensesRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collMembresRelatedByEnregistrePar !== null) {
				foreach ($this->collMembresRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collMembresRelatedByMisAJourPar !== null) {
				foreach ($this->collMembresRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collRecettesRelatedByEnregistrePar !== null) {
				foreach ($this->collRecettesRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collRecettesRelatedByMisAJourPar !== null) {
				foreach ($this->collRecettesRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStatutsRelatedByEnregistrePar !== null) {
				foreach ($this->collStatutsRelatedByEnregistrePar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			if ($this->collStatutsRelatedByMisAJourPar !== null) {
				foreach ($this->collStatutsRelatedByMisAJourPar as $referrerFK) {
					if (!$referrerFK->isDeleted()) {
						$affectedRows += $referrerFK->save($con);
					}
				}
			}

			$this->alreadyInSave = false;

		}
		return $affectedRows;
	} // doSave()

	/**
	 * Array of ValidationFailed objects.
	 * @var        array ValidationFailed[]
	 */
	protected $validationFailures = array();

	/**
	 * Gets any ValidationFailed objects that resulted from last call to validate().
	 *
	 *
	 * @return     array ValidationFailed[]
	 * @see        validate()
	 */
	public function getValidationFailures()
	{
		return $this->validationFailures;
	}

	/**
	 * Validates the objects modified field values and all objects related to this table.
	 *
	 * If $columns is either a column name or an array of column names
	 * only those columns are validated.
	 *
	 * @param      mixed $columns Column name or an array of column names.
	 * @return     boolean Whether all columns pass validation.
	 * @see        doValidate()
	 * @see        getValidationFailures()
	 */
	public function validate($columns = null)
	{
		$res = $this->doValidate($columns);
		if ($res === true) {
			$this->validationFailures = array();
			return true;
		} else {
			$this->validationFailures = $res;
			return false;
		}
	}

	/**
	 * This function performs the validation work for complex object models.
	 *
	 * In addition to checking the current object, all related objects will
	 * also be validated.  If all pass then <code>true</code> is returned; otherwise
	 * an aggreagated array of ValidationFailed objects will be returned.
	 *
	 * @param      array $columns Array of column names to validate.
	 * @return     mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
	 */
	protected function doValidate($columns = null)
	{
		if (!$this->alreadyInValidation) {
			$this->alreadyInValidation = true;
			$retval = null;

			$failureMap = array();


			// We call the validate method on the following object(s) if they
			// were passed to this object by their coresponding set
			// method.  This object relates to these object(s) by a
			// foreign key reference.

			if ($this->aStatut !== null) {
				if (!$this->aStatut->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aStatut->getValidationFailures());
				}
			}

			if ($this->aAssociation !== null) {
				if (!$this->aAssociation->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aAssociation->getValidationFailures());
				}
			}

			if ($this->aMembreRelatedByEnregistrePar !== null) {
				if (!$this->aMembreRelatedByEnregistrePar->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aMembreRelatedByEnregistrePar->getValidationFailures());
				}
			}

			if ($this->aMembreRelatedByMisAJourPar !== null) {
				if (!$this->aMembreRelatedByMisAJourPar->validate($columns)) {
					$failureMap = array_merge($failureMap, $this->aMembreRelatedByMisAJourPar->getValidationFailures());
				}
			}


			if (($retval = MembrePeer::doValidate($this, $columns)) !== true) {
				$failureMap = array_merge($failureMap, $retval);
			}


				if ($this->collAclCredentials !== null) {
					foreach ($this->collAclCredentials as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collActivitesRelatedByEnregistrePar !== null) {
					foreach ($this->collActivitesRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collActivitesRelatedByMisAJourPar !== null) {
					foreach ($this->collActivitesRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collAssociationsRelatedByEnregistrePar !== null) {
					foreach ($this->collAssociationsRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collAssociationsRelatedByMisAJourPar !== null) {
					foreach ($this->collAssociationsRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collComptesRelatedByEnregistrePar !== null) {
					foreach ($this->collComptesRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collComptesRelatedByMisAJourPar !== null) {
					foreach ($this->collComptesRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCotisationsRelatedByMembreId !== null) {
					foreach ($this->collCotisationsRelatedByMembreId as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCotisationsRelatedByEnregistrePar !== null) {
					foreach ($this->collCotisationsRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCotisationsRelatedByMisAJourPar !== null) {
					foreach ($this->collCotisationsRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCotisationTypesRelatedByEnregistrePar !== null) {
					foreach ($this->collCotisationTypesRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collCotisationTypesRelatedByMisAJourPar !== null) {
					foreach ($this->collCotisationTypesRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDepensesRelatedByEnregistrePar !== null) {
					foreach ($this->collDepensesRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collDepensesRelatedByMisAJourPar !== null) {
					foreach ($this->collDepensesRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collMembresRelatedByEnregistrePar !== null) {
					foreach ($this->collMembresRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collMembresRelatedByMisAJourPar !== null) {
					foreach ($this->collMembresRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collRecettesRelatedByEnregistrePar !== null) {
					foreach ($this->collRecettesRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collRecettesRelatedByMisAJourPar !== null) {
					foreach ($this->collRecettesRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStatutsRelatedByEnregistrePar !== null) {
					foreach ($this->collStatutsRelatedByEnregistrePar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}

				if ($this->collStatutsRelatedByMisAJourPar !== null) {
					foreach ($this->collStatutsRelatedByMisAJourPar as $referrerFK) {
						if (!$referrerFK->validate($columns)) {
							$failureMap = array_merge($failureMap, $referrerFK->getValidationFailures());
						}
					}
				}


			$this->alreadyInValidation = false;
		}

		return (!empty($failureMap) ? $failureMap : true);
	}

	/**
	 * Retrieves a field from the object by name passed in as a string.
	 *
	 * @param      string $name name
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     mixed Value of field.
	 */
	public function getByName($name, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = MembrePeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		$field = $this->getByPosition($pos);
		return $field;
	}

	/**
	 * Retrieves a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @return     mixed Value of field at $pos
	 */
	public function getByPosition($pos)
	{
		switch($pos) {
			case 0:
				return $this->getId();
				break;
			case 1:
				return $this->getNom();
				break;
			case 2:
				return $this->getPrenom();
				break;
			case 3:
				return $this->getPseudo();
				break;
			case 4:
				return $this->getPassword();
				break;
			case 5:
				return $this->getStatutId();
				break;
			case 6:
				return $this->getDateInscription();
				break;
			case 7:
				return $this->getExempteCotisation();
				break;
			case 8:
				return $this->getRue();
				break;
			case 9:
				return $this->getCp();
				break;
			case 10:
				return $this->getVille();
				break;
			case 11:
				return $this->getPays();
				break;
			case 12:
				return $this->getPicture();
				break;
			case 13:
				return $this->getEmail();
				break;
			case 14:
				return $this->getWebsite();
				break;
			case 15:
				return $this->getTelFixe();
				break;
			case 16:
				return $this->getTelPortable();
				break;
			case 17:
				return $this->getActif();
				break;
			case 18:
				return $this->getAssociationId();
				break;
			case 19:
				return $this->getEnregistrePar();
				break;
			case 20:
				return $this->getMisAJourPar();
				break;
			case 21:
				return $this->getCreatedAt();
				break;
			case 22:
				return $this->getUpdatedAt();
				break;
			default:
				return null;
				break;
		} // switch()
	}

	/**
	 * Exports the object as an array.
	 *
	 * You can specify the key type of the array by passing one of the class
	 * type constants.
	 *
	 * @param      string $keyType (optional) One of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                        BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM. Defaults to BasePeer::TYPE_PHPNAME.
	 * @param      boolean $includeLazyLoadColumns (optional) Whether to include lazy loaded columns.  Defaults to TRUE.
	 * @return     an associative array containing the field names (as keys) and field values
	 */
	public function toArray($keyType = BasePeer::TYPE_PHPNAME, $includeLazyLoadColumns = true)
	{
		$keys = MembrePeer::getFieldNames($keyType);
		$result = array(
			$keys[0] => $this->getId(),
			$keys[1] => $this->getNom(),
			$keys[2] => $this->getPrenom(),
			$keys[3] => $this->getPseudo(),
			$keys[4] => $this->getPassword(),
			$keys[5] => $this->getStatutId(),
			$keys[6] => $this->getDateInscription(),
			$keys[7] => $this->getExempteCotisation(),
			$keys[8] => $this->getRue(),
			$keys[9] => $this->getCp(),
			$keys[10] => $this->getVille(),
			$keys[11] => $this->getPays(),
			$keys[12] => $this->getPicture(),
			$keys[13] => $this->getEmail(),
			$keys[14] => $this->getWebsite(),
			$keys[15] => $this->getTelFixe(),
			$keys[16] => $this->getTelPortable(),
			$keys[17] => $this->getActif(),
			$keys[18] => $this->getAssociationId(),
			$keys[19] => $this->getEnregistrePar(),
			$keys[20] => $this->getMisAJourPar(),
			$keys[21] => $this->getCreatedAt(),
			$keys[22] => $this->getUpdatedAt(),
		);
		return $result;
	}

	/**
	 * Sets a field from the object by name passed in as a string.
	 *
	 * @param      string $name peer name
	 * @param      mixed $value field value
	 * @param      string $type The type of fieldname the $name is of:
	 *                     one of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME
	 *                     BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM
	 * @return     void
	 */
	public function setByName($name, $value, $type = BasePeer::TYPE_PHPNAME)
	{
		$pos = MembrePeer::translateFieldName($name, $type, BasePeer::TYPE_NUM);
		return $this->setByPosition($pos, $value);
	}

	/**
	 * Sets a field from the object by Position as specified in the xml schema.
	 * Zero-based.
	 *
	 * @param      int $pos position in xml schema
	 * @param      mixed $value field value
	 * @return     void
	 */
	public function setByPosition($pos, $value)
	{
		switch($pos) {
			case 0:
				$this->setId($value);
				break;
			case 1:
				$this->setNom($value);
				break;
			case 2:
				$this->setPrenom($value);
				break;
			case 3:
				$this->setPseudo($value);
				break;
			case 4:
				$this->setPassword($value);
				break;
			case 5:
				$this->setStatutId($value);
				break;
			case 6:
				$this->setDateInscription($value);
				break;
			case 7:
				$this->setExempteCotisation($value);
				break;
			case 8:
				$this->setRue($value);
				break;
			case 9:
				$this->setCp($value);
				break;
			case 10:
				$this->setVille($value);
				break;
			case 11:
				$this->setPays($value);
				break;
			case 12:
				$this->setPicture($value);
				break;
			case 13:
				$this->setEmail($value);
				break;
			case 14:
				$this->setWebsite($value);
				break;
			case 15:
				$this->setTelFixe($value);
				break;
			case 16:
				$this->setTelPortable($value);
				break;
			case 17:
				$this->setActif($value);
				break;
			case 18:
				$this->setAssociationId($value);
				break;
			case 19:
				$this->setEnregistrePar($value);
				break;
			case 20:
				$this->setMisAJourPar($value);
				break;
			case 21:
				$this->setCreatedAt($value);
				break;
			case 22:
				$this->setUpdatedAt($value);
				break;
		} // switch()
	}

	/**
	 * Populates the object using an array.
	 *
	 * This is particularly useful when populating an object from one of the
	 * request arrays (e.g. $_POST).  This method goes through the column
	 * names, checking to see whether a matching key exists in populated
	 * array. If so the setByName() method is called for that column.
	 *
	 * You can specify the key type of the array by additionally passing one
	 * of the class type constants BasePeer::TYPE_PHPNAME, BasePeer::TYPE_STUDLYPHPNAME,
	 * BasePeer::TYPE_COLNAME, BasePeer::TYPE_FIELDNAME, BasePeer::TYPE_NUM.
	 * The default key type is the column's phpname (e.g. 'AuthorId')
	 *
	 * @param      array  $arr     An array to populate the object from.
	 * @param      string $keyType The type of keys the array uses.
	 * @return     void
	 */
	public function fromArray($arr, $keyType = BasePeer::TYPE_PHPNAME)
	{
		$keys = MembrePeer::getFieldNames($keyType);

		if (array_key_exists($keys[0], $arr)) $this->setId($arr[$keys[0]]);
		if (array_key_exists($keys[1], $arr)) $this->setNom($arr[$keys[1]]);
		if (array_key_exists($keys[2], $arr)) $this->setPrenom($arr[$keys[2]]);
		if (array_key_exists($keys[3], $arr)) $this->setPseudo($arr[$keys[3]]);
		if (array_key_exists($keys[4], $arr)) $this->setPassword($arr[$keys[4]]);
		if (array_key_exists($keys[5], $arr)) $this->setStatutId($arr[$keys[5]]);
		if (array_key_exists($keys[6], $arr)) $this->setDateInscription($arr[$keys[6]]);
		if (array_key_exists($keys[7], $arr)) $this->setExempteCotisation($arr[$keys[7]]);
		if (array_key_exists($keys[8], $arr)) $this->setRue($arr[$keys[8]]);
		if (array_key_exists($keys[9], $arr)) $this->setCp($arr[$keys[9]]);
		if (array_key_exists($keys[10], $arr)) $this->setVille($arr[$keys[10]]);
		if (array_key_exists($keys[11], $arr)) $this->setPays($arr[$keys[11]]);
		if (array_key_exists($keys[12], $arr)) $this->setPicture($arr[$keys[12]]);
		if (array_key_exists($keys[13], $arr)) $this->setEmail($arr[$keys[13]]);
		if (array_key_exists($keys[14], $arr)) $this->setWebsite($arr[$keys[14]]);
		if (array_key_exists($keys[15], $arr)) $this->setTelFixe($arr[$keys[15]]);
		if (array_key_exists($keys[16], $arr)) $this->setTelPortable($arr[$keys[16]]);
		if (array_key_exists($keys[17], $arr)) $this->setActif($arr[$keys[17]]);
		if (array_key_exists($keys[18], $arr)) $this->setAssociationId($arr[$keys[18]]);
		if (array_key_exists($keys[19], $arr)) $this->setEnregistrePar($arr[$keys[19]]);
		if (array_key_exists($keys[20], $arr)) $this->setMisAJourPar($arr[$keys[20]]);
		if (array_key_exists($keys[21], $arr)) $this->setCreatedAt($arr[$keys[21]]);
		if (array_key_exists($keys[22], $arr)) $this->setUpdatedAt($arr[$keys[22]]);
	}

	/**
	 * Build a Criteria object containing the values of all modified columns in this object.
	 *
	 * @return     Criteria The Criteria object containing all modified values.
	 */
	public function buildCriteria()
	{
		$criteria = new Criteria(MembrePeer::DATABASE_NAME);

		if ($this->isColumnModified(MembrePeer::ID)) $criteria->add(MembrePeer::ID, $this->id);
		if ($this->isColumnModified(MembrePeer::NOM)) $criteria->add(MembrePeer::NOM, $this->nom);
		if ($this->isColumnModified(MembrePeer::PRENOM)) $criteria->add(MembrePeer::PRENOM, $this->prenom);
		if ($this->isColumnModified(MembrePeer::PSEUDO)) $criteria->add(MembrePeer::PSEUDO, $this->pseudo);
		if ($this->isColumnModified(MembrePeer::PASSWORD)) $criteria->add(MembrePeer::PASSWORD, $this->password);
		if ($this->isColumnModified(MembrePeer::STATUT_ID)) $criteria->add(MembrePeer::STATUT_ID, $this->statut_id);
		if ($this->isColumnModified(MembrePeer::DATE_INSCRIPTION)) $criteria->add(MembrePeer::DATE_INSCRIPTION, $this->date_inscription);
		if ($this->isColumnModified(MembrePeer::EXEMPTE_COTISATION)) $criteria->add(MembrePeer::EXEMPTE_COTISATION, $this->exempte_cotisation);
		if ($this->isColumnModified(MembrePeer::RUE)) $criteria->add(MembrePeer::RUE, $this->rue);
		if ($this->isColumnModified(MembrePeer::CP)) $criteria->add(MembrePeer::CP, $this->cp);
		if ($this->isColumnModified(MembrePeer::VILLE)) $criteria->add(MembrePeer::VILLE, $this->ville);
		if ($this->isColumnModified(MembrePeer::PAYS)) $criteria->add(MembrePeer::PAYS, $this->pays);
		if ($this->isColumnModified(MembrePeer::PICTURE)) $criteria->add(MembrePeer::PICTURE, $this->picture);
		if ($this->isColumnModified(MembrePeer::EMAIL)) $criteria->add(MembrePeer::EMAIL, $this->email);
		if ($this->isColumnModified(MembrePeer::WEBSITE)) $criteria->add(MembrePeer::WEBSITE, $this->website);
		if ($this->isColumnModified(MembrePeer::TEL_FIXE)) $criteria->add(MembrePeer::TEL_FIXE, $this->tel_fixe);
		if ($this->isColumnModified(MembrePeer::TEL_PORTABLE)) $criteria->add(MembrePeer::TEL_PORTABLE, $this->tel_portable);
		if ($this->isColumnModified(MembrePeer::ACTIF)) $criteria->add(MembrePeer::ACTIF, $this->actif);
		if ($this->isColumnModified(MembrePeer::ASSOCIATION_ID)) $criteria->add(MembrePeer::ASSOCIATION_ID, $this->association_id);
		if ($this->isColumnModified(MembrePeer::ENREGISTRE_PAR)) $criteria->add(MembrePeer::ENREGISTRE_PAR, $this->enregistre_par);
		if ($this->isColumnModified(MembrePeer::MIS_A_JOUR_PAR)) $criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->mis_a_jour_par);
		if ($this->isColumnModified(MembrePeer::CREATED_AT)) $criteria->add(MembrePeer::CREATED_AT, $this->created_at);
		if ($this->isColumnModified(MembrePeer::UPDATED_AT)) $criteria->add(MembrePeer::UPDATED_AT, $this->updated_at);

		return $criteria;
	}

	/**
	 * Builds a Criteria object containing the primary key for this object.
	 *
	 * Unlike buildCriteria() this method includes the primary key values regardless
	 * of whether or not they have been modified.
	 *
	 * @return     Criteria The Criteria object containing value(s) for primary key(s).
	 */
	public function buildPkeyCriteria()
	{
		$criteria = new Criteria(MembrePeer::DATABASE_NAME);

		$criteria->add(MembrePeer::ID, $this->id);

		return $criteria;
	}

	/**
	 * Returns the primary key for this object (row).
	 * @return     int
	 */
	public function getPrimaryKey()
	{
		return $this->getId();
	}

	/**
	 * Generic method to set the primary key (id column).
	 *
	 * @param      int $key Primary key.
	 * @return     void
	 */
	public function setPrimaryKey($key)
	{
		$this->setId($key);
	}

	/**
	 * Sets contents of passed object to values from current object.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      object $copyObj An object of Membre (or compatible) type.
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @throws     PropelException
	 */
	public function copyInto($copyObj, $deepCopy = false)
	{

		$copyObj->setNom($this->nom);

		$copyObj->setPrenom($this->prenom);

		$copyObj->setPseudo($this->pseudo);

		$copyObj->setPassword($this->password);

		$copyObj->setStatutId($this->statut_id);

		$copyObj->setDateInscription($this->date_inscription);

		$copyObj->setExempteCotisation($this->exempte_cotisation);

		$copyObj->setRue($this->rue);

		$copyObj->setCp($this->cp);

		$copyObj->setVille($this->ville);

		$copyObj->setPays($this->pays);

		$copyObj->setPicture($this->picture);

		$copyObj->setEmail($this->email);

		$copyObj->setWebsite($this->website);

		$copyObj->setTelFixe($this->tel_fixe);

		$copyObj->setTelPortable($this->tel_portable);

		$copyObj->setActif($this->actif);

		$copyObj->setAssociationId($this->association_id);

		$copyObj->setEnregistrePar($this->enregistre_par);

		$copyObj->setMisAJourPar($this->mis_a_jour_par);

		$copyObj->setCreatedAt($this->created_at);

		$copyObj->setUpdatedAt($this->updated_at);


		if ($deepCopy) {
			// important: temporarily setNew(false) because this affects the behavior of
			// the getter/setter methods for fkey referrer objects.
			$copyObj->setNew(false);

			foreach ($this->getAclCredentials() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAclCredential($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getActivitesRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addActiviteRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getActivitesRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addActiviteRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getAssociationsRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAssociationRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getAssociationsRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addAssociationRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getComptesRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCompteRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getComptesRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCompteRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCotisationsRelatedByMembreId() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCotisationRelatedByMembreId($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCotisationsRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCotisationRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCotisationsRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCotisationRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCotisationTypesRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCotisationTypeRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getCotisationTypesRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addCotisationTypeRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDepensesRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDepenseRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getDepensesRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addDepenseRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getMembresRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addMembreRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getMembresRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addMembreRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getRecettesRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addRecetteRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getRecettesRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addRecetteRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStatutsRelatedByEnregistrePar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStatutRelatedByEnregistrePar($relObj->copy($deepCopy));
				}
			}

			foreach ($this->getStatutsRelatedByMisAJourPar() as $relObj) {
				if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
					$copyObj->addStatutRelatedByMisAJourPar($relObj->copy($deepCopy));
				}
			}

		} // if ($deepCopy)


		$copyObj->setNew(true);

		$copyObj->setId(NULL); // this is a auto-increment column, so set to default value

	}

	/**
	 * Makes a copy of this object that will be inserted as a new row in table when saved.
	 * It creates a new object filling in the simple attributes, but skipping any primary
	 * keys that are defined for the table.
	 *
	 * If desired, this method can also make copies of all associated (fkey referrers)
	 * objects.
	 *
	 * @param      boolean $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
	 * @return     Membre Clone of current object.
	 * @throws     PropelException
	 */
	public function copy($deepCopy = false)
	{
		// we use get_class(), because this might be a subclass
		$clazz = get_class($this);
		$copyObj = new $clazz();
		$this->copyInto($copyObj, $deepCopy);
		return $copyObj;
	}

	/**
	 * Returns a peer instance associated with this om.
	 *
	 * Since Peer classes are not to have any instance attributes, this method returns the
	 * same instance for all member of this class. The method could therefore
	 * be static, but this would prevent one from overriding the behavior.
	 *
	 * @return     MembrePeer
	 */
	public function getPeer()
	{
		if (self::$peer === null) {
			self::$peer = new MembrePeer();
		}
		return self::$peer;
	}

	/**
	 * Declares an association between this object and a Statut object.
	 *
	 * @param      Statut $v
	 * @return     Membre The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setStatut(Statut $v = null)
	{
		if ($v === null) {
			$this->setStatutId(NULL);
		} else {
			$this->setStatutId($v->getId());
		}

		$this->aStatut = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Statut object, it will not be re-added.
		if ($v !== null) {
			$v->addMembre($this);
		}

		return $this;
	}


	/**
	 * Get the associated Statut object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Statut The associated Statut object.
	 * @throws     PropelException
	 */
	public function getStatut(PropelPDO $con = null)
	{
		if ($this->aStatut === null && ($this->statut_id !== null)) {
			$c = new Criteria(StatutPeer::DATABASE_NAME);
			$c->add(StatutPeer::ID, $this->statut_id);
			$this->aStatut = StatutPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aStatut->addMembres($this);
			 */
		}
		return $this->aStatut;
	}

	/**
	 * Declares an association between this object and a Association object.
	 *
	 * @param      Association $v
	 * @return     Membre The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setAssociation(Association $v = null)
	{
		if ($v === null) {
			$this->setAssociationId(NULL);
		} else {
			$this->setAssociationId($v->getId());
		}

		$this->aAssociation = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Association object, it will not be re-added.
		if ($v !== null) {
			$v->addMembre($this);
		}

		return $this;
	}


	/**
	 * Get the associated Association object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Association The associated Association object.
	 * @throws     PropelException
	 */
	public function getAssociation(PropelPDO $con = null)
	{
		if ($this->aAssociation === null && ($this->association_id !== null)) {
			$c = new Criteria(AssociationPeer::DATABASE_NAME);
			$c->add(AssociationPeer::ID, $this->association_id);
			$this->aAssociation = AssociationPeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aAssociation->addMembres($this);
			 */
		}
		return $this->aAssociation;
	}

	/**
	 * Declares an association between this object and a Membre object.
	 *
	 * @param      Membre $v
	 * @return     Membre The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setMembreRelatedByEnregistrePar(Membre $v = null)
	{
		if ($v === null) {
			$this->setEnregistrePar(NULL);
		} else {
			$this->setEnregistrePar($v->getId());
		}

		$this->aMembreRelatedByEnregistrePar = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Membre object, it will not be re-added.
		if ($v !== null) {
			$v->addMembreRelatedByEnregistrePar($this);
		}

		return $this;
	}


	/**
	 * Get the associated Membre object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Membre The associated Membre object.
	 * @throws     PropelException
	 */
	public function getMembreRelatedByEnregistrePar(PropelPDO $con = null)
	{
		if ($this->aMembreRelatedByEnregistrePar === null && ($this->enregistre_par !== null)) {
			$c = new Criteria(MembrePeer::DATABASE_NAME);
			$c->add(MembrePeer::ID, $this->enregistre_par);
			$this->aMembreRelatedByEnregistrePar = MembrePeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aMembreRelatedByEnregistrePar->addMembresRelatedByEnregistrePar($this);
			 */
		}
		return $this->aMembreRelatedByEnregistrePar;
	}

	/**
	 * Declares an association between this object and a Membre object.
	 *
	 * @param      Membre $v
	 * @return     Membre The current object (for fluent API support)
	 * @throws     PropelException
	 */
	public function setMembreRelatedByMisAJourPar(Membre $v = null)
	{
		if ($v === null) {
			$this->setMisAJourPar(NULL);
		} else {
			$this->setMisAJourPar($v->getId());
		}

		$this->aMembreRelatedByMisAJourPar = $v;

		// Add binding for other direction of this n:n relationship.
		// If this object has already been added to the Membre object, it will not be re-added.
		if ($v !== null) {
			$v->addMembreRelatedByMisAJourPar($this);
		}

		return $this;
	}


	/**
	 * Get the associated Membre object
	 *
	 * @param      PropelPDO Optional Connection object.
	 * @return     Membre The associated Membre object.
	 * @throws     PropelException
	 */
	public function getMembreRelatedByMisAJourPar(PropelPDO $con = null)
	{
		if ($this->aMembreRelatedByMisAJourPar === null && ($this->mis_a_jour_par !== null)) {
			$c = new Criteria(MembrePeer::DATABASE_NAME);
			$c->add(MembrePeer::ID, $this->mis_a_jour_par);
			$this->aMembreRelatedByMisAJourPar = MembrePeer::doSelectOne($c, $con);
			/* The following can be used additionally to
			   guarantee the related object contains a reference
			   to this object.  This level of coupling may, however, be
			   undesirable since it could result in an only partially populated collection
			   in the referenced object.
			   $this->aMembreRelatedByMisAJourPar->addMembresRelatedByMisAJourPar($this);
			 */
		}
		return $this->aMembreRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collAclCredentials collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAclCredentials()
	 */
	public function clearAclCredentials()
	{
		$this->collAclCredentials = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAclCredentials collection (array).
	 *
	 * By default this just sets the collAclCredentials collection to an empty array (like clearcollAclCredentials());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAclCredentials()
	{
		$this->collAclCredentials = array();
	}

	/**
	 * Gets an array of AclCredential objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related AclCredentials from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array AclCredential[]
	 * @throws     PropelException
	 */
	public function getAclCredentials($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAclCredentials === null) {
			if ($this->isNew()) {
			   $this->collAclCredentials = array();
			} else {

				$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

				AclCredentialPeer::addSelectColumns($criteria);
				$this->collAclCredentials = AclCredentialPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

				AclCredentialPeer::addSelectColumns($criteria);
				if (!isset($this->lastAclCredentialCriteria) || !$this->lastAclCredentialCriteria->equals($criteria)) {
					$this->collAclCredentials = AclCredentialPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAclCredentialCriteria = $criteria;
		return $this->collAclCredentials;
	}

	/**
	 * Returns the number of related AclCredential objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related AclCredential objects.
	 * @throws     PropelException
	 */
	public function countAclCredentials(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAclCredentials === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

				$count = AclCredentialPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

				if (!isset($this->lastAclCredentialCriteria) || !$this->lastAclCredentialCriteria->equals($criteria)) {
					$count = AclCredentialPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collAclCredentials);
				}
			} else {
				$count = count($this->collAclCredentials);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a AclCredential object to this object
	 * through the AclCredential foreign key attribute.
	 *
	 * @param      AclCredential $l AclCredential
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAclCredential(AclCredential $l)
	{
		if ($this->collAclCredentials === null) {
			$this->initAclCredentials();
		}
		if (!in_array($l, $this->collAclCredentials, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAclCredentials, $l);
			$l->setMembre($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related AclCredentials from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getAclCredentialsJoinAclAction($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAclCredentials === null) {
			if ($this->isNew()) {
				$this->collAclCredentials = array();
			} else {

				$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

				$this->collAclCredentials = AclCredentialPeer::doSelectJoinAclAction($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(AclCredentialPeer::MEMBRE_ID, $this->id);

			if (!isset($this->lastAclCredentialCriteria) || !$this->lastAclCredentialCriteria->equals($criteria)) {
				$this->collAclCredentials = AclCredentialPeer::doSelectJoinAclAction($criteria, $con, $join_behavior);
			}
		}
		$this->lastAclCredentialCriteria = $criteria;

		return $this->collAclCredentials;
	}

	/**
	 * Clears out the collActivitesRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addActivitesRelatedByEnregistrePar()
	 */
	public function clearActivitesRelatedByEnregistrePar()
	{
		$this->collActivitesRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collActivitesRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collActivitesRelatedByEnregistrePar collection to an empty array (like clearcollActivitesRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initActivitesRelatedByEnregistrePar()
	{
		$this->collActivitesRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Activite objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related ActivitesRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Activite[]
	 * @throws     PropelException
	 */
	public function getActivitesRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collActivitesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collActivitesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

				ActivitePeer::addSelectColumns($criteria);
				$this->collActivitesRelatedByEnregistrePar = ActivitePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

				ActivitePeer::addSelectColumns($criteria);
				if (!isset($this->lastActiviteRelatedByEnregistreParCriteria) || !$this->lastActiviteRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collActivitesRelatedByEnregistrePar = ActivitePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastActiviteRelatedByEnregistreParCriteria = $criteria;
		return $this->collActivitesRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Activite objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Activite objects.
	 * @throws     PropelException
	 */
	public function countActivitesRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collActivitesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

				$count = ActivitePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastActiviteRelatedByEnregistreParCriteria) || !$this->lastActiviteRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = ActivitePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collActivitesRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collActivitesRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Activite object to this object
	 * through the Activite foreign key attribute.
	 *
	 * @param      Activite $l Activite
	 * @return     void
	 * @throws     PropelException
	 */
	public function addActiviteRelatedByEnregistrePar(Activite $l)
	{
		if ($this->collActivitesRelatedByEnregistrePar === null) {
			$this->initActivitesRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collActivitesRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collActivitesRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related ActivitesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getActivitesRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collActivitesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collActivitesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

				$this->collActivitesRelatedByEnregistrePar = ActivitePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(ActivitePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastActiviteRelatedByEnregistreParCriteria) || !$this->lastActiviteRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collActivitesRelatedByEnregistrePar = ActivitePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastActiviteRelatedByEnregistreParCriteria = $criteria;

		return $this->collActivitesRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collActivitesRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addActivitesRelatedByMisAJourPar()
	 */
	public function clearActivitesRelatedByMisAJourPar()
	{
		$this->collActivitesRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collActivitesRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collActivitesRelatedByMisAJourPar collection to an empty array (like clearcollActivitesRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initActivitesRelatedByMisAJourPar()
	{
		$this->collActivitesRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Activite objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related ActivitesRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Activite[]
	 * @throws     PropelException
	 */
	public function getActivitesRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collActivitesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collActivitesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

				ActivitePeer::addSelectColumns($criteria);
				$this->collActivitesRelatedByMisAJourPar = ActivitePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

				ActivitePeer::addSelectColumns($criteria);
				if (!isset($this->lastActiviteRelatedByMisAJourParCriteria) || !$this->lastActiviteRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collActivitesRelatedByMisAJourPar = ActivitePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastActiviteRelatedByMisAJourParCriteria = $criteria;
		return $this->collActivitesRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Activite objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Activite objects.
	 * @throws     PropelException
	 */
	public function countActivitesRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collActivitesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

				$count = ActivitePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastActiviteRelatedByMisAJourParCriteria) || !$this->lastActiviteRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = ActivitePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collActivitesRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collActivitesRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Activite object to this object
	 * through the Activite foreign key attribute.
	 *
	 * @param      Activite $l Activite
	 * @return     void
	 * @throws     PropelException
	 */
	public function addActiviteRelatedByMisAJourPar(Activite $l)
	{
		if ($this->collActivitesRelatedByMisAJourPar === null) {
			$this->initActivitesRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collActivitesRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collActivitesRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related ActivitesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getActivitesRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collActivitesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collActivitesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collActivitesRelatedByMisAJourPar = ActivitePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(ActivitePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastActiviteRelatedByMisAJourParCriteria) || !$this->lastActiviteRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collActivitesRelatedByMisAJourPar = ActivitePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastActiviteRelatedByMisAJourParCriteria = $criteria;

		return $this->collActivitesRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collAssociationsRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAssociationsRelatedByEnregistrePar()
	 */
	public function clearAssociationsRelatedByEnregistrePar()
	{
		$this->collAssociationsRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAssociationsRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collAssociationsRelatedByEnregistrePar collection to an empty array (like clearcollAssociationsRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAssociationsRelatedByEnregistrePar()
	{
		$this->collAssociationsRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Association objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related AssociationsRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Association[]
	 * @throws     PropelException
	 */
	public function getAssociationsRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAssociationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collAssociationsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(AssociationPeer::ENREGISTRE_PAR, $this->id);

				AssociationPeer::addSelectColumns($criteria);
				$this->collAssociationsRelatedByEnregistrePar = AssociationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AssociationPeer::ENREGISTRE_PAR, $this->id);

				AssociationPeer::addSelectColumns($criteria);
				if (!isset($this->lastAssociationRelatedByEnregistreParCriteria) || !$this->lastAssociationRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collAssociationsRelatedByEnregistrePar = AssociationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAssociationRelatedByEnregistreParCriteria = $criteria;
		return $this->collAssociationsRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Association objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Association objects.
	 * @throws     PropelException
	 */
	public function countAssociationsRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAssociationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AssociationPeer::ENREGISTRE_PAR, $this->id);

				$count = AssociationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AssociationPeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastAssociationRelatedByEnregistreParCriteria) || !$this->lastAssociationRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = AssociationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collAssociationsRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collAssociationsRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Association object to this object
	 * through the Association foreign key attribute.
	 *
	 * @param      Association $l Association
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAssociationRelatedByEnregistrePar(Association $l)
	{
		if ($this->collAssociationsRelatedByEnregistrePar === null) {
			$this->initAssociationsRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collAssociationsRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAssociationsRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}

	/**
	 * Clears out the collAssociationsRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addAssociationsRelatedByMisAJourPar()
	 */
	public function clearAssociationsRelatedByMisAJourPar()
	{
		$this->collAssociationsRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collAssociationsRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collAssociationsRelatedByMisAJourPar collection to an empty array (like clearcollAssociationsRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initAssociationsRelatedByMisAJourPar()
	{
		$this->collAssociationsRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Association objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related AssociationsRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Association[]
	 * @throws     PropelException
	 */
	public function getAssociationsRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collAssociationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collAssociationsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(AssociationPeer::MIS_A_JOUR_PAR, $this->id);

				AssociationPeer::addSelectColumns($criteria);
				$this->collAssociationsRelatedByMisAJourPar = AssociationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(AssociationPeer::MIS_A_JOUR_PAR, $this->id);

				AssociationPeer::addSelectColumns($criteria);
				if (!isset($this->lastAssociationRelatedByMisAJourParCriteria) || !$this->lastAssociationRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collAssociationsRelatedByMisAJourPar = AssociationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastAssociationRelatedByMisAJourParCriteria = $criteria;
		return $this->collAssociationsRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Association objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Association objects.
	 * @throws     PropelException
	 */
	public function countAssociationsRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collAssociationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(AssociationPeer::MIS_A_JOUR_PAR, $this->id);

				$count = AssociationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(AssociationPeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastAssociationRelatedByMisAJourParCriteria) || !$this->lastAssociationRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = AssociationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collAssociationsRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collAssociationsRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Association object to this object
	 * through the Association foreign key attribute.
	 *
	 * @param      Association $l Association
	 * @return     void
	 * @throws     PropelException
	 */
	public function addAssociationRelatedByMisAJourPar(Association $l)
	{
		if ($this->collAssociationsRelatedByMisAJourPar === null) {
			$this->initAssociationsRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collAssociationsRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collAssociationsRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}

	/**
	 * Clears out the collComptesRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addComptesRelatedByEnregistrePar()
	 */
	public function clearComptesRelatedByEnregistrePar()
	{
		$this->collComptesRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collComptesRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collComptesRelatedByEnregistrePar collection to an empty array (like clearcollComptesRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initComptesRelatedByEnregistrePar()
	{
		$this->collComptesRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Compte objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related ComptesRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Compte[]
	 * @throws     PropelException
	 */
	public function getComptesRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collComptesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collComptesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

				ComptePeer::addSelectColumns($criteria);
				$this->collComptesRelatedByEnregistrePar = ComptePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

				ComptePeer::addSelectColumns($criteria);
				if (!isset($this->lastCompteRelatedByEnregistreParCriteria) || !$this->lastCompteRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collComptesRelatedByEnregistrePar = ComptePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCompteRelatedByEnregistreParCriteria = $criteria;
		return $this->collComptesRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Compte objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Compte objects.
	 * @throws     PropelException
	 */
	public function countComptesRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collComptesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

				$count = ComptePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastCompteRelatedByEnregistreParCriteria) || !$this->lastCompteRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = ComptePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collComptesRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collComptesRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Compte object to this object
	 * through the Compte foreign key attribute.
	 *
	 * @param      Compte $l Compte
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCompteRelatedByEnregistrePar(Compte $l)
	{
		if ($this->collComptesRelatedByEnregistrePar === null) {
			$this->initComptesRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collComptesRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collComptesRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related ComptesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getComptesRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collComptesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collComptesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

				$this->collComptesRelatedByEnregistrePar = ComptePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(ComptePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastCompteRelatedByEnregistreParCriteria) || !$this->lastCompteRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collComptesRelatedByEnregistrePar = ComptePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCompteRelatedByEnregistreParCriteria = $criteria;

		return $this->collComptesRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collComptesRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addComptesRelatedByMisAJourPar()
	 */
	public function clearComptesRelatedByMisAJourPar()
	{
		$this->collComptesRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collComptesRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collComptesRelatedByMisAJourPar collection to an empty array (like clearcollComptesRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initComptesRelatedByMisAJourPar()
	{
		$this->collComptesRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Compte objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related ComptesRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Compte[]
	 * @throws     PropelException
	 */
	public function getComptesRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collComptesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collComptesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

				ComptePeer::addSelectColumns($criteria);
				$this->collComptesRelatedByMisAJourPar = ComptePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

				ComptePeer::addSelectColumns($criteria);
				if (!isset($this->lastCompteRelatedByMisAJourParCriteria) || !$this->lastCompteRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collComptesRelatedByMisAJourPar = ComptePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCompteRelatedByMisAJourParCriteria = $criteria;
		return $this->collComptesRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Compte objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Compte objects.
	 * @throws     PropelException
	 */
	public function countComptesRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collComptesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

				$count = ComptePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastCompteRelatedByMisAJourParCriteria) || !$this->lastCompteRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = ComptePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collComptesRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collComptesRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Compte object to this object
	 * through the Compte foreign key attribute.
	 *
	 * @param      Compte $l Compte
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCompteRelatedByMisAJourPar(Compte $l)
	{
		if ($this->collComptesRelatedByMisAJourPar === null) {
			$this->initComptesRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collComptesRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collComptesRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related ComptesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getComptesRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collComptesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collComptesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collComptesRelatedByMisAJourPar = ComptePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(ComptePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastCompteRelatedByMisAJourParCriteria) || !$this->lastCompteRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collComptesRelatedByMisAJourPar = ComptePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCompteRelatedByMisAJourParCriteria = $criteria;

		return $this->collComptesRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collCotisationsRelatedByMembreId collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCotisationsRelatedByMembreId()
	 */
	public function clearCotisationsRelatedByMembreId()
	{
		$this->collCotisationsRelatedByMembreId = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCotisationsRelatedByMembreId collection (array).
	 *
	 * By default this just sets the collCotisationsRelatedByMembreId collection to an empty array (like clearcollCotisationsRelatedByMembreId());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCotisationsRelatedByMembreId()
	{
		$this->collCotisationsRelatedByMembreId = array();
	}

	/**
	 * Gets an array of Cotisation objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related CotisationsRelatedByMembreId from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Cotisation[]
	 * @throws     PropelException
	 */
	public function getCotisationsRelatedByMembreId($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMembreId === null) {
			if ($this->isNew()) {
			   $this->collCotisationsRelatedByMembreId = array();
			} else {

				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				if (!isset($this->lastCotisationRelatedByMembreIdCriteria) || !$this->lastCotisationRelatedByMembreIdCriteria->equals($criteria)) {
					$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCotisationRelatedByMembreIdCriteria = $criteria;
		return $this->collCotisationsRelatedByMembreId;
	}

	/**
	 * Returns the number of related Cotisation objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Cotisation objects.
	 * @throws     PropelException
	 */
	public function countCotisationsRelatedByMembreId(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCotisationsRelatedByMembreId === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				$count = CotisationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				if (!isset($this->lastCotisationRelatedByMembreIdCriteria) || !$this->lastCotisationRelatedByMembreIdCriteria->equals($criteria)) {
					$count = CotisationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCotisationsRelatedByMembreId);
				}
			} else {
				$count = count($this->collCotisationsRelatedByMembreId);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Cotisation object to this object
	 * through the Cotisation foreign key attribute.
	 *
	 * @param      Cotisation $l Cotisation
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCotisationRelatedByMembreId(Cotisation $l)
	{
		if ($this->collCotisationsRelatedByMembreId === null) {
			$this->initCotisationsRelatedByMembreId();
		}
		if (!in_array($l, $this->collCotisationsRelatedByMembreId, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCotisationsRelatedByMembreId, $l);
			$l->setMembreRelatedByMembreId($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByMembreId from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByMembreIdJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMembreId === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByMembreId = array();
			} else {

				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

			if (!isset($this->lastCotisationRelatedByMembreIdCriteria) || !$this->lastCotisationRelatedByMembreIdCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByMembreIdCriteria = $criteria;

		return $this->collCotisationsRelatedByMembreId;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByMembreId from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByMembreIdJoinCotisationType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMembreId === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByMembreId = array();
			} else {

				$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

				$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::MEMBRE_ID, $this->id);

			if (!isset($this->lastCotisationRelatedByMembreIdCriteria) || !$this->lastCotisationRelatedByMembreIdCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByMembreId = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByMembreIdCriteria = $criteria;

		return $this->collCotisationsRelatedByMembreId;
	}

	/**
	 * Clears out the collCotisationsRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCotisationsRelatedByEnregistrePar()
	 */
	public function clearCotisationsRelatedByEnregistrePar()
	{
		$this->collCotisationsRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCotisationsRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collCotisationsRelatedByEnregistrePar collection to an empty array (like clearcollCotisationsRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCotisationsRelatedByEnregistrePar()
	{
		$this->collCotisationsRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Cotisation objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related CotisationsRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Cotisation[]
	 * @throws     PropelException
	 */
	public function getCotisationsRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collCotisationsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				if (!isset($this->lastCotisationRelatedByEnregistreParCriteria) || !$this->lastCotisationRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCotisationRelatedByEnregistreParCriteria = $criteria;
		return $this->collCotisationsRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Cotisation objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Cotisation objects.
	 * @throws     PropelException
	 */
	public function countCotisationsRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCotisationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				$count = CotisationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastCotisationRelatedByEnregistreParCriteria) || !$this->lastCotisationRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = CotisationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCotisationsRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collCotisationsRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Cotisation object to this object
	 * through the Cotisation foreign key attribute.
	 *
	 * @param      Cotisation $l Cotisation
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCotisationRelatedByEnregistrePar(Cotisation $l)
	{
		if ($this->collCotisationsRelatedByEnregistrePar === null) {
			$this->initCotisationsRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collCotisationsRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCotisationsRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByEnregistreParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastCotisationRelatedByEnregistreParCriteria) || !$this->lastCotisationRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByEnregistreParCriteria = $criteria;

		return $this->collCotisationsRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByEnregistreParJoinCotisationType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

				$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastCotisationRelatedByEnregistreParCriteria) || !$this->lastCotisationRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByEnregistrePar = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByEnregistreParCriteria = $criteria;

		return $this->collCotisationsRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collCotisationsRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCotisationsRelatedByMisAJourPar()
	 */
	public function clearCotisationsRelatedByMisAJourPar()
	{
		$this->collCotisationsRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCotisationsRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collCotisationsRelatedByMisAJourPar collection to an empty array (like clearcollCotisationsRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCotisationsRelatedByMisAJourPar()
	{
		$this->collCotisationsRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Cotisation objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related CotisationsRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Cotisation[]
	 * @throws     PropelException
	 */
	public function getCotisationsRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collCotisationsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				CotisationPeer::addSelectColumns($criteria);
				if (!isset($this->lastCotisationRelatedByMisAJourParCriteria) || !$this->lastCotisationRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCotisationRelatedByMisAJourParCriteria = $criteria;
		return $this->collCotisationsRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Cotisation objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Cotisation objects.
	 * @throws     PropelException
	 */
	public function countCotisationsRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCotisationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				$count = CotisationPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastCotisationRelatedByMisAJourParCriteria) || !$this->lastCotisationRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = CotisationPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCotisationsRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collCotisationsRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Cotisation object to this object
	 * through the Cotisation foreign key attribute.
	 *
	 * @param      Cotisation $l Cotisation
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCotisationRelatedByMisAJourPar(Cotisation $l)
	{
		if ($this->collCotisationsRelatedByMisAJourPar === null) {
			$this->initCotisationsRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collCotisationsRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCotisationsRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByMisAJourParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastCotisationRelatedByMisAJourParCriteria) || !$this->lastCotisationRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByMisAJourParCriteria = $criteria;

		return $this->collCotisationsRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationsRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationsRelatedByMisAJourParJoinCotisationType($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collCotisationsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

				$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationPeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastCotisationRelatedByMisAJourParCriteria) || !$this->lastCotisationRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collCotisationsRelatedByMisAJourPar = CotisationPeer::doSelectJoinCotisationType($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationRelatedByMisAJourParCriteria = $criteria;

		return $this->collCotisationsRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collCotisationTypesRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCotisationTypesRelatedByEnregistrePar()
	 */
	public function clearCotisationTypesRelatedByEnregistrePar()
	{
		$this->collCotisationTypesRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCotisationTypesRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collCotisationTypesRelatedByEnregistrePar collection to an empty array (like clearcollCotisationTypesRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCotisationTypesRelatedByEnregistrePar()
	{
		$this->collCotisationTypesRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of CotisationType objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related CotisationTypesRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array CotisationType[]
	 * @throws     PropelException
	 */
	public function getCotisationTypesRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationTypesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collCotisationTypesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

				CotisationTypePeer::addSelectColumns($criteria);
				$this->collCotisationTypesRelatedByEnregistrePar = CotisationTypePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

				CotisationTypePeer::addSelectColumns($criteria);
				if (!isset($this->lastCotisationTypeRelatedByEnregistreParCriteria) || !$this->lastCotisationTypeRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collCotisationTypesRelatedByEnregistrePar = CotisationTypePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCotisationTypeRelatedByEnregistreParCriteria = $criteria;
		return $this->collCotisationTypesRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related CotisationType objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related CotisationType objects.
	 * @throws     PropelException
	 */
	public function countCotisationTypesRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCotisationTypesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

				$count = CotisationTypePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastCotisationTypeRelatedByEnregistreParCriteria) || !$this->lastCotisationTypeRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = CotisationTypePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCotisationTypesRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collCotisationTypesRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a CotisationType object to this object
	 * through the CotisationType foreign key attribute.
	 *
	 * @param      CotisationType $l CotisationType
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCotisationTypeRelatedByEnregistrePar(CotisationType $l)
	{
		if ($this->collCotisationTypesRelatedByEnregistrePar === null) {
			$this->initCotisationTypesRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collCotisationTypesRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCotisationTypesRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationTypesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationTypesRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationTypesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collCotisationTypesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

				$this->collCotisationTypesRelatedByEnregistrePar = CotisationTypePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationTypePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastCotisationTypeRelatedByEnregistreParCriteria) || !$this->lastCotisationTypeRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collCotisationTypesRelatedByEnregistrePar = CotisationTypePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationTypeRelatedByEnregistreParCriteria = $criteria;

		return $this->collCotisationTypesRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collCotisationTypesRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addCotisationTypesRelatedByMisAJourPar()
	 */
	public function clearCotisationTypesRelatedByMisAJourPar()
	{
		$this->collCotisationTypesRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collCotisationTypesRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collCotisationTypesRelatedByMisAJourPar collection to an empty array (like clearcollCotisationTypesRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initCotisationTypesRelatedByMisAJourPar()
	{
		$this->collCotisationTypesRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of CotisationType objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related CotisationTypesRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array CotisationType[]
	 * @throws     PropelException
	 */
	public function getCotisationTypesRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationTypesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collCotisationTypesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

				CotisationTypePeer::addSelectColumns($criteria);
				$this->collCotisationTypesRelatedByMisAJourPar = CotisationTypePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

				CotisationTypePeer::addSelectColumns($criteria);
				if (!isset($this->lastCotisationTypeRelatedByMisAJourParCriteria) || !$this->lastCotisationTypeRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collCotisationTypesRelatedByMisAJourPar = CotisationTypePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastCotisationTypeRelatedByMisAJourParCriteria = $criteria;
		return $this->collCotisationTypesRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related CotisationType objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related CotisationType objects.
	 * @throws     PropelException
	 */
	public function countCotisationTypesRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collCotisationTypesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

				$count = CotisationTypePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastCotisationTypeRelatedByMisAJourParCriteria) || !$this->lastCotisationTypeRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = CotisationTypePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collCotisationTypesRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collCotisationTypesRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a CotisationType object to this object
	 * through the CotisationType foreign key attribute.
	 *
	 * @param      CotisationType $l CotisationType
	 * @return     void
	 * @throws     PropelException
	 */
	public function addCotisationTypeRelatedByMisAJourPar(CotisationType $l)
	{
		if ($this->collCotisationTypesRelatedByMisAJourPar === null) {
			$this->initCotisationTypesRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collCotisationTypesRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collCotisationTypesRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related CotisationTypesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getCotisationTypesRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collCotisationTypesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collCotisationTypesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collCotisationTypesRelatedByMisAJourPar = CotisationTypePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(CotisationTypePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastCotisationTypeRelatedByMisAJourParCriteria) || !$this->lastCotisationTypeRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collCotisationTypesRelatedByMisAJourPar = CotisationTypePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastCotisationTypeRelatedByMisAJourParCriteria = $criteria;

		return $this->collCotisationTypesRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collDepensesRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDepensesRelatedByEnregistrePar()
	 */
	public function clearDepensesRelatedByEnregistrePar()
	{
		$this->collDepensesRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDepensesRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collDepensesRelatedByEnregistrePar collection to an empty array (like clearcollDepensesRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDepensesRelatedByEnregistrePar()
	{
		$this->collDepensesRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Depense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related DepensesRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Depense[]
	 * @throws     PropelException
	 */
	public function getDepensesRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collDepensesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				DepensePeer::addSelectColumns($criteria);
				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				DepensePeer::addSelectColumns($criteria);
				if (!isset($this->lastDepenseRelatedByEnregistreParCriteria) || !$this->lastDepenseRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDepenseRelatedByEnregistreParCriteria = $criteria;
		return $this->collDepensesRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Depense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Depense objects.
	 * @throws     PropelException
	 */
	public function countDepensesRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDepensesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				$count = DepensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastDepenseRelatedByEnregistreParCriteria) || !$this->lastDepenseRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = DepensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collDepensesRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collDepensesRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Depense object to this object
	 * through the Depense foreign key attribute.
	 *
	 * @param      Depense $l Depense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDepenseRelatedByEnregistrePar(Depense $l)
	{
		if ($this->collDepensesRelatedByEnregistrePar === null) {
			$this->initDepensesRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collDepensesRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDepensesRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByEnregistreParCriteria) || !$this->lastDepenseRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByEnregistreParCriteria = $criteria;

		return $this->collDepensesRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByEnregistreParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByEnregistreParCriteria) || !$this->lastDepenseRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByEnregistreParCriteria = $criteria;

		return $this->collDepensesRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByEnregistreParJoinActivite($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByEnregistreParCriteria) || !$this->lastDepenseRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByEnregistrePar = DepensePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByEnregistreParCriteria = $criteria;

		return $this->collDepensesRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collDepensesRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addDepensesRelatedByMisAJourPar()
	 */
	public function clearDepensesRelatedByMisAJourPar()
	{
		$this->collDepensesRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collDepensesRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collDepensesRelatedByMisAJourPar collection to an empty array (like clearcollDepensesRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initDepensesRelatedByMisAJourPar()
	{
		$this->collDepensesRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Depense objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related DepensesRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Depense[]
	 * @throws     PropelException
	 */
	public function getDepensesRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collDepensesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				DepensePeer::addSelectColumns($criteria);
				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				DepensePeer::addSelectColumns($criteria);
				if (!isset($this->lastDepenseRelatedByMisAJourParCriteria) || !$this->lastDepenseRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastDepenseRelatedByMisAJourParCriteria = $criteria;
		return $this->collDepensesRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Depense objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Depense objects.
	 * @throws     PropelException
	 */
	public function countDepensesRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collDepensesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				$count = DepensePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastDepenseRelatedByMisAJourParCriteria) || !$this->lastDepenseRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = DepensePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collDepensesRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collDepensesRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Depense object to this object
	 * through the Depense foreign key attribute.
	 *
	 * @param      Depense $l Depense
	 * @return     void
	 * @throws     PropelException
	 */
	public function addDepenseRelatedByMisAJourPar(Depense $l)
	{
		if ($this->collDepensesRelatedByMisAJourPar === null) {
			$this->initDepensesRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collDepensesRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collDepensesRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByMisAJourParCriteria) || !$this->lastDepenseRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByMisAJourParCriteria = $criteria;

		return $this->collDepensesRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByMisAJourParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByMisAJourParCriteria) || !$this->lastDepenseRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByMisAJourParCriteria = $criteria;

		return $this->collDepensesRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related DepensesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getDepensesRelatedByMisAJourParJoinActivite($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collDepensesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collDepensesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(DepensePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastDepenseRelatedByMisAJourParCriteria) || !$this->lastDepenseRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collDepensesRelatedByMisAJourPar = DepensePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		}
		$this->lastDepenseRelatedByMisAJourParCriteria = $criteria;

		return $this->collDepensesRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collMembresRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addMembresRelatedByEnregistrePar()
	 */
	public function clearMembresRelatedByEnregistrePar()
	{
		$this->collMembresRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collMembresRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collMembresRelatedByEnregistrePar collection to an empty array (like clearcollMembresRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initMembresRelatedByEnregistrePar()
	{
		$this->collMembresRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Membre objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related MembresRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Membre[]
	 * @throws     PropelException
	 */
	public function getMembresRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collMembresRelatedByEnregistrePar = array();
			} else {

				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				MembrePeer::addSelectColumns($criteria);
				$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				MembrePeer::addSelectColumns($criteria);
				if (!isset($this->lastMembreRelatedByEnregistreParCriteria) || !$this->lastMembreRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastMembreRelatedByEnregistreParCriteria = $criteria;
		return $this->collMembresRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Membre objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Membre objects.
	 * @throws     PropelException
	 */
	public function countMembresRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collMembresRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				$count = MembrePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastMembreRelatedByEnregistreParCriteria) || !$this->lastMembreRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = MembrePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collMembresRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collMembresRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Membre object to this object
	 * through the Membre foreign key attribute.
	 *
	 * @param      Membre $l Membre
	 * @return     void
	 * @throws     PropelException
	 */
	public function addMembreRelatedByEnregistrePar(Membre $l)
	{
		if ($this->collMembresRelatedByEnregistrePar === null) {
			$this->initMembresRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collMembresRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collMembresRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related MembresRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getMembresRelatedByEnregistreParJoinStatut($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collMembresRelatedByEnregistrePar = array();
			} else {

				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelectJoinStatut($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastMembreRelatedByEnregistreParCriteria) || !$this->lastMembreRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelectJoinStatut($criteria, $con, $join_behavior);
			}
		}
		$this->lastMembreRelatedByEnregistreParCriteria = $criteria;

		return $this->collMembresRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related MembresRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getMembresRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collMembresRelatedByEnregistrePar = array();
			} else {

				$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

				$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(MembrePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastMembreRelatedByEnregistreParCriteria) || !$this->lastMembreRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collMembresRelatedByEnregistrePar = MembrePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastMembreRelatedByEnregistreParCriteria = $criteria;

		return $this->collMembresRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collMembresRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addMembresRelatedByMisAJourPar()
	 */
	public function clearMembresRelatedByMisAJourPar()
	{
		$this->collMembresRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collMembresRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collMembresRelatedByMisAJourPar collection to an empty array (like clearcollMembresRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initMembresRelatedByMisAJourPar()
	{
		$this->collMembresRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Membre objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related MembresRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Membre[]
	 * @throws     PropelException
	 */
	public function getMembresRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collMembresRelatedByMisAJourPar = array();
			} else {

				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				MembrePeer::addSelectColumns($criteria);
				$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				MembrePeer::addSelectColumns($criteria);
				if (!isset($this->lastMembreRelatedByMisAJourParCriteria) || !$this->lastMembreRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastMembreRelatedByMisAJourParCriteria = $criteria;
		return $this->collMembresRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Membre objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Membre objects.
	 * @throws     PropelException
	 */
	public function countMembresRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collMembresRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				$count = MembrePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastMembreRelatedByMisAJourParCriteria) || !$this->lastMembreRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = MembrePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collMembresRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collMembresRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Membre object to this object
	 * through the Membre foreign key attribute.
	 *
	 * @param      Membre $l Membre
	 * @return     void
	 * @throws     PropelException
	 */
	public function addMembreRelatedByMisAJourPar(Membre $l)
	{
		if ($this->collMembresRelatedByMisAJourPar === null) {
			$this->initMembresRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collMembresRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collMembresRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related MembresRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getMembresRelatedByMisAJourParJoinStatut($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collMembresRelatedByMisAJourPar = array();
			} else {

				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelectJoinStatut($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastMembreRelatedByMisAJourParCriteria) || !$this->lastMembreRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelectJoinStatut($criteria, $con, $join_behavior);
			}
		}
		$this->lastMembreRelatedByMisAJourParCriteria = $criteria;

		return $this->collMembresRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related MembresRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getMembresRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collMembresRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collMembresRelatedByMisAJourPar = array();
			} else {

				$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(MembrePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastMembreRelatedByMisAJourParCriteria) || !$this->lastMembreRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collMembresRelatedByMisAJourPar = MembrePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastMembreRelatedByMisAJourParCriteria = $criteria;

		return $this->collMembresRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collRecettesRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addRecettesRelatedByEnregistrePar()
	 */
	public function clearRecettesRelatedByEnregistrePar()
	{
		$this->collRecettesRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collRecettesRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collRecettesRelatedByEnregistrePar collection to an empty array (like clearcollRecettesRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initRecettesRelatedByEnregistrePar()
	{
		$this->collRecettesRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Recette objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related RecettesRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Recette[]
	 * @throws     PropelException
	 */
	public function getRecettesRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collRecettesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				RecettePeer::addSelectColumns($criteria);
				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				RecettePeer::addSelectColumns($criteria);
				if (!isset($this->lastRecetteRelatedByEnregistreParCriteria) || !$this->lastRecetteRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastRecetteRelatedByEnregistreParCriteria = $criteria;
		return $this->collRecettesRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Recette objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Recette objects.
	 * @throws     PropelException
	 */
	public function countRecettesRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collRecettesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				$count = RecettePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastRecetteRelatedByEnregistreParCriteria) || !$this->lastRecetteRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = RecettePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collRecettesRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collRecettesRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Recette object to this object
	 * through the Recette foreign key attribute.
	 *
	 * @param      Recette $l Recette
	 * @return     void
	 * @throws     PropelException
	 */
	public function addRecetteRelatedByEnregistrePar(Recette $l)
	{
		if ($this->collRecettesRelatedByEnregistrePar === null) {
			$this->initRecettesRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collRecettesRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collRecettesRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByEnregistreParCriteria) || !$this->lastRecetteRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByEnregistreParCriteria = $criteria;

		return $this->collRecettesRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByEnregistreParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByEnregistreParCriteria) || !$this->lastRecetteRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByEnregistreParCriteria = $criteria;

		return $this->collRecettesRelatedByEnregistrePar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByEnregistreParJoinActivite($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByEnregistrePar = array();
			} else {

				$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByEnregistreParCriteria) || !$this->lastRecetteRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByEnregistrePar = RecettePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByEnregistreParCriteria = $criteria;

		return $this->collRecettesRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collRecettesRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addRecettesRelatedByMisAJourPar()
	 */
	public function clearRecettesRelatedByMisAJourPar()
	{
		$this->collRecettesRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collRecettesRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collRecettesRelatedByMisAJourPar collection to an empty array (like clearcollRecettesRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initRecettesRelatedByMisAJourPar()
	{
		$this->collRecettesRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Recette objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related RecettesRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Recette[]
	 * @throws     PropelException
	 */
	public function getRecettesRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collRecettesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				RecettePeer::addSelectColumns($criteria);
				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				RecettePeer::addSelectColumns($criteria);
				if (!isset($this->lastRecetteRelatedByMisAJourParCriteria) || !$this->lastRecetteRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastRecetteRelatedByMisAJourParCriteria = $criteria;
		return $this->collRecettesRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Recette objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Recette objects.
	 * @throws     PropelException
	 */
	public function countRecettesRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collRecettesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				$count = RecettePeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastRecetteRelatedByMisAJourParCriteria) || !$this->lastRecetteRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = RecettePeer::doCount($criteria, $con);
				} else {
					$count = count($this->collRecettesRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collRecettesRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Recette object to this object
	 * through the Recette foreign key attribute.
	 *
	 * @param      Recette $l Recette
	 * @return     void
	 * @throws     PropelException
	 */
	public function addRecetteRelatedByMisAJourPar(Recette $l)
	{
		if ($this->collRecettesRelatedByMisAJourPar === null) {
			$this->initRecettesRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collRecettesRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collRecettesRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByMisAJourParCriteria) || !$this->lastRecetteRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByMisAJourParCriteria = $criteria;

		return $this->collRecettesRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByMisAJourParJoinCompte($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByMisAJourParCriteria) || !$this->lastRecetteRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinCompte($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByMisAJourParCriteria = $criteria;

		return $this->collRecettesRelatedByMisAJourPar;
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related RecettesRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getRecettesRelatedByMisAJourParJoinActivite($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collRecettesRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collRecettesRelatedByMisAJourPar = array();
			} else {

				$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(RecettePeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastRecetteRelatedByMisAJourParCriteria) || !$this->lastRecetteRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collRecettesRelatedByMisAJourPar = RecettePeer::doSelectJoinActivite($criteria, $con, $join_behavior);
			}
		}
		$this->lastRecetteRelatedByMisAJourParCriteria = $criteria;

		return $this->collRecettesRelatedByMisAJourPar;
	}

	/**
	 * Clears out the collStatutsRelatedByEnregistrePar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStatutsRelatedByEnregistrePar()
	 */
	public function clearStatutsRelatedByEnregistrePar()
	{
		$this->collStatutsRelatedByEnregistrePar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStatutsRelatedByEnregistrePar collection (array).
	 *
	 * By default this just sets the collStatutsRelatedByEnregistrePar collection to an empty array (like clearcollStatutsRelatedByEnregistrePar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStatutsRelatedByEnregistrePar()
	{
		$this->collStatutsRelatedByEnregistrePar = array();
	}

	/**
	 * Gets an array of Statut objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related StatutsRelatedByEnregistrePar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Statut[]
	 * @throws     PropelException
	 */
	public function getStatutsRelatedByEnregistrePar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStatutsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
			   $this->collStatutsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

				StatutPeer::addSelectColumns($criteria);
				$this->collStatutsRelatedByEnregistrePar = StatutPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

				StatutPeer::addSelectColumns($criteria);
				if (!isset($this->lastStatutRelatedByEnregistreParCriteria) || !$this->lastStatutRelatedByEnregistreParCriteria->equals($criteria)) {
					$this->collStatutsRelatedByEnregistrePar = StatutPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStatutRelatedByEnregistreParCriteria = $criteria;
		return $this->collStatutsRelatedByEnregistrePar;
	}

	/**
	 * Returns the number of related Statut objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Statut objects.
	 * @throws     PropelException
	 */
	public function countStatutsRelatedByEnregistrePar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStatutsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

				$count = StatutPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

				if (!isset($this->lastStatutRelatedByEnregistreParCriteria) || !$this->lastStatutRelatedByEnregistreParCriteria->equals($criteria)) {
					$count = StatutPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStatutsRelatedByEnregistrePar);
				}
			} else {
				$count = count($this->collStatutsRelatedByEnregistrePar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Statut object to this object
	 * through the Statut foreign key attribute.
	 *
	 * @param      Statut $l Statut
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStatutRelatedByEnregistrePar(Statut $l)
	{
		if ($this->collStatutsRelatedByEnregistrePar === null) {
			$this->initStatutsRelatedByEnregistrePar();
		}
		if (!in_array($l, $this->collStatutsRelatedByEnregistrePar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStatutsRelatedByEnregistrePar, $l);
			$l->setMembreRelatedByEnregistrePar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related StatutsRelatedByEnregistrePar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getStatutsRelatedByEnregistreParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStatutsRelatedByEnregistrePar === null) {
			if ($this->isNew()) {
				$this->collStatutsRelatedByEnregistrePar = array();
			} else {

				$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

				$this->collStatutsRelatedByEnregistrePar = StatutPeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StatutPeer::ENREGISTRE_PAR, $this->id);

			if (!isset($this->lastStatutRelatedByEnregistreParCriteria) || !$this->lastStatutRelatedByEnregistreParCriteria->equals($criteria)) {
				$this->collStatutsRelatedByEnregistrePar = StatutPeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastStatutRelatedByEnregistreParCriteria = $criteria;

		return $this->collStatutsRelatedByEnregistrePar;
	}

	/**
	 * Clears out the collStatutsRelatedByMisAJourPar collection (array).
	 *
	 * This does not modify the database; however, it will remove any associated objects, causing
	 * them to be refetched by subsequent calls to accessor method.
	 *
	 * @return     void
	 * @see        addStatutsRelatedByMisAJourPar()
	 */
	public function clearStatutsRelatedByMisAJourPar()
	{
		$this->collStatutsRelatedByMisAJourPar = null; // important to set this to NULL since that means it is uninitialized
	}

	/**
	 * Initializes the collStatutsRelatedByMisAJourPar collection (array).
	 *
	 * By default this just sets the collStatutsRelatedByMisAJourPar collection to an empty array (like clearcollStatutsRelatedByMisAJourPar());
	 * however, you may wish to override this method in your stub class to provide setting appropriate
	 * to your application -- for example, setting the initial array to the values stored in database.
	 *
	 * @return     void
	 */
	public function initStatutsRelatedByMisAJourPar()
	{
		$this->collStatutsRelatedByMisAJourPar = array();
	}

	/**
	 * Gets an array of Statut objects which contain a foreign key that references this object.
	 *
	 * If this collection has already been initialized with an identical Criteria, it returns the collection.
	 * Otherwise if this Membre has previously been saved, it will retrieve
	 * related StatutsRelatedByMisAJourPar from storage. If this Membre is new, it will return
	 * an empty collection or the current collection, the criteria is ignored on a new object.
	 *
	 * @param      PropelPDO $con
	 * @param      Criteria $criteria
	 * @return     array Statut[]
	 * @throws     PropelException
	 */
	public function getStatutsRelatedByMisAJourPar($criteria = null, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStatutsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
			   $this->collStatutsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

				StatutPeer::addSelectColumns($criteria);
				$this->collStatutsRelatedByMisAJourPar = StatutPeer::doSelect($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return the collection.


				$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

				StatutPeer::addSelectColumns($criteria);
				if (!isset($this->lastStatutRelatedByMisAJourParCriteria) || !$this->lastStatutRelatedByMisAJourParCriteria->equals($criteria)) {
					$this->collStatutsRelatedByMisAJourPar = StatutPeer::doSelect($criteria, $con);
				}
			}
		}
		$this->lastStatutRelatedByMisAJourParCriteria = $criteria;
		return $this->collStatutsRelatedByMisAJourPar;
	}

	/**
	 * Returns the number of related Statut objects.
	 *
	 * @param      Criteria $criteria
	 * @param      boolean $distinct
	 * @param      PropelPDO $con
	 * @return     int Count of related Statut objects.
	 * @throws     PropelException
	 */
	public function countStatutsRelatedByMisAJourPar(Criteria $criteria = null, $distinct = false, PropelPDO $con = null)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		} else {
			$criteria = clone $criteria;
		}

		if ($distinct) {
			$criteria->setDistinct();
		}

		$count = null;

		if ($this->collStatutsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$count = 0;
			} else {

				$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

				$count = StatutPeer::doCount($criteria, $con);
			}
		} else {
			// criteria has no effect for a new object
			if (!$this->isNew()) {
				// the following code is to determine if a new query is
				// called for.  If the criteria is the same as the last
				// one, just return count of the collection.


				$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

				if (!isset($this->lastStatutRelatedByMisAJourParCriteria) || !$this->lastStatutRelatedByMisAJourParCriteria->equals($criteria)) {
					$count = StatutPeer::doCount($criteria, $con);
				} else {
					$count = count($this->collStatutsRelatedByMisAJourPar);
				}
			} else {
				$count = count($this->collStatutsRelatedByMisAJourPar);
			}
		}
		return $count;
	}

	/**
	 * Method called to associate a Statut object to this object
	 * through the Statut foreign key attribute.
	 *
	 * @param      Statut $l Statut
	 * @return     void
	 * @throws     PropelException
	 */
	public function addStatutRelatedByMisAJourPar(Statut $l)
	{
		if ($this->collStatutsRelatedByMisAJourPar === null) {
			$this->initStatutsRelatedByMisAJourPar();
		}
		if (!in_array($l, $this->collStatutsRelatedByMisAJourPar, true)) { // only add it if the **same** object is not already associated
			array_push($this->collStatutsRelatedByMisAJourPar, $l);
			$l->setMembreRelatedByMisAJourPar($this);
		}
	}


	/**
	 * If this collection has already been initialized with
	 * an identical criteria, it returns the collection.
	 * Otherwise if this Membre is new, it will return
	 * an empty collection; or if this Membre has previously
	 * been saved, it will retrieve related StatutsRelatedByMisAJourPar from storage.
	 *
	 * This method is protected by default in order to keep the public
	 * api reasonable.  You can provide public methods for those you
	 * actually need in Membre.
	 */
	public function getStatutsRelatedByMisAJourParJoinAssociation($criteria = null, $con = null, $join_behavior = Criteria::LEFT_JOIN)
	{
		if ($criteria === null) {
			$criteria = new Criteria(MembrePeer::DATABASE_NAME);
		}
		elseif ($criteria instanceof Criteria)
		{
			$criteria = clone $criteria;
		}

		if ($this->collStatutsRelatedByMisAJourPar === null) {
			if ($this->isNew()) {
				$this->collStatutsRelatedByMisAJourPar = array();
			} else {

				$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

				$this->collStatutsRelatedByMisAJourPar = StatutPeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		} else {
			// the following code is to determine if a new query is
			// called for.  If the criteria is the same as the last
			// one, just return the collection.

			$criteria->add(StatutPeer::MIS_A_JOUR_PAR, $this->id);

			if (!isset($this->lastStatutRelatedByMisAJourParCriteria) || !$this->lastStatutRelatedByMisAJourParCriteria->equals($criteria)) {
				$this->collStatutsRelatedByMisAJourPar = StatutPeer::doSelectJoinAssociation($criteria, $con, $join_behavior);
			}
		}
		$this->lastStatutRelatedByMisAJourParCriteria = $criteria;

		return $this->collStatutsRelatedByMisAJourPar;
	}

	/**
	 * Resets all collections of referencing foreign keys.
	 *
	 * This method is a user-space workaround for PHP's inability to garbage collect objects
	 * with circular references.  This is currently necessary when using Propel in certain
	 * daemon or large-volumne/high-memory operations.
	 *
	 * @param      boolean $deep Whether to also clear the references on all associated objects.
	 */
	public function clearAllReferences($deep = false)
	{
		if ($deep) {
			if ($this->collAclCredentials) {
				foreach ((array) $this->collAclCredentials as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collActivitesRelatedByEnregistrePar) {
				foreach ((array) $this->collActivitesRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collActivitesRelatedByMisAJourPar) {
				foreach ((array) $this->collActivitesRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collAssociationsRelatedByEnregistrePar) {
				foreach ((array) $this->collAssociationsRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collAssociationsRelatedByMisAJourPar) {
				foreach ((array) $this->collAssociationsRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collComptesRelatedByEnregistrePar) {
				foreach ((array) $this->collComptesRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collComptesRelatedByMisAJourPar) {
				foreach ((array) $this->collComptesRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCotisationsRelatedByMembreId) {
				foreach ((array) $this->collCotisationsRelatedByMembreId as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCotisationsRelatedByEnregistrePar) {
				foreach ((array) $this->collCotisationsRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCotisationsRelatedByMisAJourPar) {
				foreach ((array) $this->collCotisationsRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCotisationTypesRelatedByEnregistrePar) {
				foreach ((array) $this->collCotisationTypesRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collCotisationTypesRelatedByMisAJourPar) {
				foreach ((array) $this->collCotisationTypesRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDepensesRelatedByEnregistrePar) {
				foreach ((array) $this->collDepensesRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collDepensesRelatedByMisAJourPar) {
				foreach ((array) $this->collDepensesRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collMembresRelatedByEnregistrePar) {
				foreach ((array) $this->collMembresRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collMembresRelatedByMisAJourPar) {
				foreach ((array) $this->collMembresRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collRecettesRelatedByEnregistrePar) {
				foreach ((array) $this->collRecettesRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collRecettesRelatedByMisAJourPar) {
				foreach ((array) $this->collRecettesRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStatutsRelatedByEnregistrePar) {
				foreach ((array) $this->collStatutsRelatedByEnregistrePar as $o) {
					$o->clearAllReferences($deep);
				}
			}
			if ($this->collStatutsRelatedByMisAJourPar) {
				foreach ((array) $this->collStatutsRelatedByMisAJourPar as $o) {
					$o->clearAllReferences($deep);
				}
			}
		} // if ($deep)

		$this->collAclCredentials = null;
		$this->collActivitesRelatedByEnregistrePar = null;
		$this->collActivitesRelatedByMisAJourPar = null;
		$this->collAssociationsRelatedByEnregistrePar = null;
		$this->collAssociationsRelatedByMisAJourPar = null;
		$this->collComptesRelatedByEnregistrePar = null;
		$this->collComptesRelatedByMisAJourPar = null;
		$this->collCotisationsRelatedByMembreId = null;
		$this->collCotisationsRelatedByEnregistrePar = null;
		$this->collCotisationsRelatedByMisAJourPar = null;
		$this->collCotisationTypesRelatedByEnregistrePar = null;
		$this->collCotisationTypesRelatedByMisAJourPar = null;
		$this->collDepensesRelatedByEnregistrePar = null;
		$this->collDepensesRelatedByMisAJourPar = null;
		$this->collMembresRelatedByEnregistrePar = null;
		$this->collMembresRelatedByMisAJourPar = null;
		$this->collRecettesRelatedByEnregistrePar = null;
		$this->collRecettesRelatedByMisAJourPar = null;
		$this->collStatutsRelatedByEnregistrePar = null;
		$this->collStatutsRelatedByMisAJourPar = null;
			$this->aStatut = null;
			$this->aAssociation = null;
			$this->aMembreRelatedByEnregistrePar = null;
			$this->aMembreRelatedByMisAJourPar = null;
	}


  public function __call($method, $arguments)
  {
    if (!$callable = sfMixer::getCallable('BaseMembre:'.$method))
    {
      throw new sfException(sprintf('Call to undefined method BaseMembre::%s', $method));
    }

    array_unshift($arguments, $this);

    return call_user_func_array($callable, $arguments);
  }


} // BaseMembre
